import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'dart:io';
import 'package:path_provider/path_provider.dart';
import 'package:open_filex/open_filex.dart';
import 'package:share_plus/share_plus.dart';
import '../../negocio/providers/reports_provider.dart';
import '../../negocio/providers/reports_provider.dart' as rp;
import 'widgets/date_filter_field.dart';
import 'widgets/search_select_field.dart';
import 'widgets/mini_stat_card.dart';
import 'utils/report_formatters.dart';
import 'widgets/report_table.dart';
import 'widgets/credits_list_widget.dart';
import 'widgets/balances_list_widget.dart';
import 'widgets/payments_list_widget.dart';
import 'widgets/overdue_report_widgets.dart';
import 'widgets/performance_report_widgets.dart';
import 'widgets/daily_activity_widgets.dart';
import 'widgets/projection_widgets.dart';
import 'widgets/portfolio_widgets.dart';
import 'widgets/commission_widgets.dart';
import 'widgets/users_distribution_widget.dart';
import 'widgets/download_buttons_widget.dart';

class ReportsScreen extends ConsumerStatefulWidget {
  final String userRole; // 'manager' o 'cobrador'

  const ReportsScreen({super.key, required this.userRole});

  @override
  ConsumerState<ReportsScreen> createState() => _ReportsScreenState();
}

class _ReportsScreenState extends ConsumerState<ReportsScreen> {
  String? _selectedReport;
  Map<String, dynamic> _filters = {};
  String _format = 'json';
  rp.ReportRequest? _currentRequest;
  int? _quickRangeIndex;
  bool _showFilters = true; // Controla si los filtros est√°n visibles

  bool _hasDateRange(dynamic typeDef) {
    final filters = (typeDef?['filters'] as List<dynamic>?) ?? [];
    return filters.any(
      (f) => f.toString() == 'start_date' || f.toString() == 'end_date',
    );
  }

  Map<String, String> _rangeForIndex(int idx) {
    final now = DateTime.now();
    String iso(DateTime d) => d.toIso8601String().split('T').first;
    if (idx == 0) {
      final d = DateTime(now.year, now.month, now.day);
      return {'start': iso(d), 'end': iso(d)};
    } else if (idx == 1) {
      final d = DateTime(
        now.year,
        now.month,
        now.day,
      ).subtract(const Duration(days: 1));
      return {'start': iso(d), 'end': iso(d)};
    } else if (idx == 2) {
      final end = DateTime(now.year, now.month, now.day);
      final start = end.subtract(const Duration(days: 6));
      return {'start': iso(start), 'end': iso(end)};
    } else if (idx == 3) {
      final start = DateTime(now.year, now.month, 1);
      final end = DateTime(now.year, now.month, now.day);
      return {'start': iso(start), 'end': iso(end)};
    } else {
      // Mes pasado
      final firstThis = DateTime(now.year, now.month, 1);
      final lastPrev = firstThis.subtract(const Duration(days: 1));
      final firstPrev = DateTime(lastPrev.year, lastPrev.month, 1);
      return {'start': iso(firstPrev), 'end': iso(lastPrev)};
    }
  }

  @override
  Widget build(BuildContext context) {
    final reportTypesAsync = ref.watch(reportTypesProvider);

    return Scaffold(
      backgroundColor: const Color(0xFFF5F7FB),
      appBar: AppBar(
        title: const Text('Generador de Reportes'),
        actions: [
          IconButton(
            onPressed: () {
              showAboutDialog(
                context: context,
                applicationName: 'Generador de Reportes',
                applicationVersion: '',
                children: const [
                  Text(
                    'Seleccione un tipo de reporte, configure filtros y genere resultados en JSON, Excel o PDF.',
                  ),
                ],
              );
            },
            icon: const Icon(Icons.help_outline),
            tooltip: 'Ayuda',
          ),
        ],
      ),
      body: reportTypesAsync.when(
        data: (types) {
          final entries = types.entries.toList();
          final theme = Theme.of(context);
          final cs = theme.colorScheme;
          return Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              children: [
                // üéØ CARD DE FILTROS COLAPSABLE
                Card(
                  elevation: _showFilters ? 2 : 0.5,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      // Header colapsable
                      GestureDetector(
                        onTap: () =>
                            setState(() => _showFilters = !_showFilters),
                        child: Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 16,
                            vertical: 12,
                          ),
                          decoration: BoxDecoration(
                            color: _showFilters
                                ? cs.primaryContainer.withValues(alpha: 0.3)
                                : cs.surfaceContainerHighest.withValues(
                                    alpha: 0.5,
                                  ),
                            borderRadius: const BorderRadius.only(
                              topLeft: Radius.circular(12),
                              topRight: Radius.circular(12),
                            ),
                          ),
                          child: Row(
                            children: [
                              Icon(
                                _showFilters
                                    ? Icons.filter_alt
                                    : Icons.filter_alt_off,
                                color: cs.primary,
                                size: 20,
                              ),
                              const SizedBox(width: 12),
                              Expanded(
                                child: Text(
                                  'Filtros de b√∫squeda',
                                  style: theme.textTheme.titleSmall?.copyWith(
                                    fontWeight: FontWeight.w600,
                                    color: cs.primary,
                                  ),
                                ),
                              ),
                              AnimatedRotation(
                                turns: _showFilters ? 0 : 0.5,
                                duration: const Duration(milliseconds: 300),
                                child: Icon(
                                  Icons.expand_more,
                                  color: cs.primary,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                      // Contenido colapsable
                      AnimatedSize(
                        duration: const Duration(milliseconds: 300),
                        curve: Curves.easeInOut,
                        child: _showFilters
                            ? Container(
                                constraints: const BoxConstraints(
                                  maxHeight:
                                      400, // Limita altura del contenedor
                                ),
                                child: Padding(
                                  padding: const EdgeInsets.all(16.0),
                                  child: SingleChildScrollView(
                                    child: Column(
                                      mainAxisSize: MainAxisSize.min,
                                      crossAxisAlignment:
                                          CrossAxisAlignment.start,
                                      children: [
                                        // Selector de tipo de reporte
                                        Row(
                                          children: const [
                                            Icon(
                                              Icons.insights_outlined,
                                              size: 20,
                                            ),
                                            SizedBox(width: 8),
                                            Text(
                                              'Tipo de reporte',
                                              style: TextStyle(
                                                fontWeight: FontWeight.bold,
                                              ),
                                            ),
                                          ],
                                        ),
                                        const SizedBox(height: 8),
                                        Container(
                                          decoration: BoxDecoration(
                                            border: Border.all(
                                              color: cs.outline.withValues(
                                                alpha: 0.2,
                                              ),
                                            ),
                                            borderRadius: BorderRadius.circular(
                                              12,
                                            ),
                                          ),
                                          child: DropdownButton<String>(
                                            value: _selectedReport,
                                            isExpanded: true,
                                            underline: const SizedBox(),
                                            menuMaxHeight: 300,
                                            items: entries
                                                .map(
                                                  (e) => DropdownMenuItem(
                                                    value: e.key,
                                                    child: Padding(
                                                      padding:
                                                          const EdgeInsets.symmetric(
                                                            horizontal: 12,
                                                          ),
                                                      child: Text(
                                                        e.value['name'] ??
                                                            e.key,
                                                      ),
                                                    ),
                                                  ),
                                                )
                                                .toList(),
                                            onChanged: (v) => setState(() {
                                              _selectedReport = v;
                                              _quickRangeIndex = null;
                                              _filters.remove('start_date');
                                              _filters.remove('end_date');
                                            }),
                                          ),
                                        ),
                                        const SizedBox(height: 12),
                                        if (_selectedReport != null) ...[
                                          if (_hasDateRange(
                                            types[_selectedReport!],
                                          ))
                                            Padding(
                                              padding: const EdgeInsets.only(
                                                bottom: 8.0,
                                              ),
                                              child: Wrap(
                                                spacing: 8,
                                                children: List<Widget>.generate(6, (
                                                  i,
                                                ) {
                                                  final labels = [
                                                    'Hoy',
                                                    'Ayer',
                                                    '√öltimos 7 d√≠as',
                                                    'Este mes',
                                                    'Mes pasado',
                                                    'Rango de fechas',
                                                  ];
                                                  final selected =
                                                      _quickRangeIndex == i;
                                                  return ChoiceChip(
                                                    label: Text(labels[i]),
                                                    selected: selected,
                                                    labelStyle: TextStyle(
                                                      color: selected
                                                          ? cs.onPrimaryContainer
                                                          : cs.onSurfaceVariant,
                                                    ),
                                                    selectedColor:
                                                        cs.primaryContainer,
                                                    backgroundColor: cs.surface,
                                                    shape:
                                                        const StadiumBorder(),
                                                    side: BorderSide(
                                                      color: selected
                                                          ? cs.primary
                                                          : cs.outline
                                                                .withOpacity(
                                                                  0.4,
                                                                ),
                                                    ),
                                                    onSelected: (selected) {
                                                      setState(() {
                                                        if (!selected) {
                                                          _quickRangeIndex =
                                                              null;
                                                          _filters.remove(
                                                            'start_date',
                                                          );
                                                          _filters.remove(
                                                            'end_date',
                                                          );
                                                        } else {
                                                          _quickRangeIndex = i;
                                                          if (i == 5) {
                                                            _filters.remove(
                                                              'start_date',
                                                            );
                                                            _filters.remove(
                                                              'end_date',
                                                            );
                                                          } else {
                                                            final range =
                                                                _rangeForIndex(
                                                                  i,
                                                                );
                                                            _filters['start_date'] =
                                                                range['start'];
                                                            _filters['end_date'] =
                                                                range['end'];
                                                          }
                                                        }
                                                      });
                                                    },
                                                  );
                                                }),
                                              ),
                                            ),
                                          // Filtros din√°micos
                                          Flexible(
                                            child: SingleChildScrollView(
                                              child: Column(
                                                crossAxisAlignment:
                                                    CrossAxisAlignment.start,
                                                children: _buildFiltersFor(
                                                  types[_selectedReport!],
                                                ),
                                              ),
                                            ),
                                          ),
                                        ],
                                      ],
                                    ),
                                  ),
                                ),
                              )
                            : const SizedBox.shrink(),
                      ),
                      // Footer con botones de acci√≥n
                      Container(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 16,
                          vertical: 12,
                        ),
                        decoration: BoxDecoration(
                          color: cs.surfaceContainerHighest.withValues(
                            alpha: 0.3,
                          ),
                          borderRadius: const BorderRadius.only(
                            bottomLeft: Radius.circular(12),
                            bottomRight: Radius.circular(12),
                          ),
                        ),
                        child: Row(
                          children: [
                            Expanded(
                              child: Wrap(
                                spacing: 8,
                                runSpacing: 8,
                                crossAxisAlignment: WrapCrossAlignment.center,
                                children: [
                                  Text(
                                    'Formato:',
                                    style: theme.textTheme.bodySmall?.copyWith(
                                      color: cs.onSurfaceVariant,
                                    ),
                                  ),
                                  DropdownButton<String>(
                                    value: _format,
                                    items:
                                        ((types[_selectedReport]?['formats']
                                                    as List<dynamic>?) ??
                                                ['json'])
                                            .map(
                                              (f) => DropdownMenuItem(
                                                value: f as String,
                                                child: Text(
                                                  f.toString().toUpperCase(),
                                                  style:
                                                      theme.textTheme.bodySmall,
                                                ),
                                              ),
                                            )
                                            .toList(),
                                    onChanged: (v) =>
                                        setState(() => _format = v ?? 'json'),
                                  ),
                                  OutlinedButton.icon(
                                    onPressed: () {
                                      setState(() {
                                        _filters.clear();
                                        _quickRangeIndex = null;
                                      });
                                      ScaffoldMessenger.of(
                                        context,
                                      ).showSnackBar(
                                        const SnackBar(
                                          content: Text('Filtros limpiados'),
                                        ),
                                      );
                                    },
                                    icon: const Icon(Icons.clear_all, size: 18),
                                    label: const Text('Limpiar'),
                                  ),
                                ],
                              ),
                            ),
                            const SizedBox(width: 8),
                            FilledButton.icon(
                              onPressed: _selectedReport == null
                                  ? null
                                  : _generateReport,
                              icon: const Icon(Icons.play_arrow_rounded),
                              label: const Text('Generar'),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 12),
                // üìä CARD DE RESULTADOS - Ahora toma m√°s espacio
                Expanded(
                  child: Card(
                    clipBehavior: Clip.antiAlias,
                    elevation: 1,
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Padding(
                      padding: const EdgeInsets.all(12.0),
                      child: _ReportResultView(request: _currentRequest),
                    ),
                  ),
                ),
              ],
            ),
          );
        },
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (e, st) =>
            Center(child: Text('Error cargando tipos de reportes: $e')),
      ),
    );
  }

  List<Widget> _buildFiltersFor(dynamic typeDef) {
    final List<Widget> widgets = [];
    final filters = (typeDef?['filters'] as List<dynamic>?) ?? [];

    // Helper para traducir nombres de campos
    String _translateFilterLabel(String key) {
      final normalized = key.toLowerCase().replaceAll('_', ' ');

      // Diccionario de traducciones exactas
      final translations = {
        'start date': 'Fecha Inicio',
        'start_date': 'Fecha Inicio',
        'end date': 'Fecha Fin',
        'end_date': 'Fecha Fin',
        'client': 'Cliente',
        'client name': 'Nombre Cliente',
        'client_name': 'Nombre Cliente',
        'cobrador': 'Cobrador',
        'cobrador name': 'Nombre Cobrador',
        'cobrador_name': 'Nombre Cobrador',
        'category': 'Categor√≠a',
        'categoria': 'Categor√≠a',
        'status': 'Estado',
        'credit status': 'Estado Cr√©dito',
        'credit_status': 'Estado Cr√©dito',
        'payment status': 'Estado Pago',
        'payment_status': 'Estado Pago',
        'amount': 'Monto',
        'total amount': 'Monto Total',
        'total_amount': 'Monto Total',
        'date': 'Fecha',
        'id': 'ID',
        'name': 'Nombre',
        'type': 'Tipo',
        'description': 'Descripci√≥n',
        'reason': 'Motivo',
        'notes': 'Notas',
        'observation': 'Observaci√≥n',
        'balance': 'Balance',
        'paid': 'Pagado',
        'pending': 'Pendiente',
        'overdue': 'Vencido',
        'overdue days': 'D√≠as Vencido',
        'overdue_days': 'D√≠as Vencido',
        'user': 'Usuario',
        'username': 'Nombre Usuario',
        'email': 'Correo',
        'phone': 'Tel√©fono',
        'location': 'Ubicaci√≥n',
        'address': 'Direcci√≥n',
        'city': 'Ciudad',
        'state': 'Estado',
        'country': 'Pa√≠s',
        'zip code': 'C√≥digo Postal',
        'zip_code': 'C√≥digo Postal',
        'created at': 'Creado',
        'created_at': 'Creado',
        'updated at': 'Actualizado',
        'updated_at': 'Actualizado',
        'deleted at': 'Eliminado',
        'deleted_at': 'Eliminado',
        'is active': 'Activo',
        'is_active': 'Activo',
        'frequency': 'Frecuencia',
        'interest': 'Inter√©s',
        'commission': 'Comisi√≥n',
        'source': 'Origen',
        'bank': 'Banco',
        'account': 'Cuenta',
        'reference': 'Referencia',
        'payment': 'Pago',
        'payment date': 'Fecha Pago',
        'payment_date': 'Fecha Pago',
        'credit': 'Cr√©dito',
        'credit id': 'ID Cr√©dito',
        'credit_id': 'ID Cr√©dito',
        'client id': 'ID Cliente',
        'client_id': 'ID Cliente',
        'cobrador id': 'ID Cobrador',
        'cobrador_id': 'ID Cobrador',
        'user id': 'ID Usuario',
        'user_id': 'ID Usuario',
        'period': 'Per√≠odo',
        'month': 'Mes',
        'year': 'A√±o',
        'week': 'Semana',
        'day': 'D√≠a',
        'range': 'Rango',
        'minimum': 'M√≠nimo',
        'maximum': 'M√°ximo',
        'min': 'M√≠nimo',
        'max': 'M√°ximo',
        'total': 'Total',
        'count': 'Cantidad',
        'quantity': 'Cantidad',
        'rate': 'Tasa',
        'percentage': 'Porcentaje',
        'percent': 'Porcentaje',
        'summary': 'Resumen',
        'detail': 'Detalle',
        'details': 'Detalles',
        'active': 'Activo',
        'inactive': 'Inactivo',
        'enabled': 'Habilitado',
        'disabled': 'Deshabilitado',
        'open': 'Abierto',
        'closed': 'Cerrado',
        'reconciled': 'Reconciliado',
        'pending payment': 'Pago Pendiente',
        'pending_payment': 'Pago Pendiente',
        'paid payment': 'Pago Realizado',
        'paid_payment': 'Pago Realizado',
        'rejected': 'Rechazado',
        'approved': 'Aprobado',
        'collection': 'Cobranza',
        'collected': 'Cobrado',
        'lent': 'Prestado',
        'owed': 'Adeudado',
        'efficiency': 'Eficiencia',
        'performance': 'Rendimiento',
      };

      // Buscar traducci√≥n exacta
      if (translations.containsKey(normalized)) {
        return translations[normalized]!;
      }

      // B√∫squeda por palabras clave si no hay match exacto
      for (final keyword in translations.keys) {
        if (normalized.contains(keyword)) {
          return translations[keyword]!;
        }
      }

      // Si no hay traducci√≥n, formatear el nombre: capitalizar cada palabra
      return key
          .replaceAll('_', ' ')
          .split(' ')
          .map(
            (word) => word.isEmpty
                ? ''
                : word[0].toUpperCase() + word.substring(1).toLowerCase(),
          )
          .join(' ');
    }

    for (final f in filters) {
      final key = f as String;

      // Heur√≠stica simple: si el nombre del filtro contiene 'date' o 'fecha', usar date picker
      final isDate =
          key.toLowerCase().contains('date') ||
          key.toLowerCase().contains('fecha');

      // Heur√≠stica para campos que ser√°n search-selects: cobrador, cliente, categoria
      final isCobrador = key.toLowerCase().contains('cobrador');
      final isCliente =
          key.toLowerCase().contains('client') ||
          key.toLowerCase().contains('cliente');
      final isCategoria =
          key.toLowerCase().contains('categoria') ||
          key.toLowerCase().contains('category');

      if (isDate) {
        // Mostrar inputs de fecha solo cuando el usuario seleccione "Rango de fechas"
        final isManualRange =
            _quickRangeIndex == 5; // √≠ndice 5 = Rango de fechas
        if (!isManualRange) {
          // Ocultar campos de fecha si no est√° seleccionado el rango manual
          continue;
        }
        widgets.add(
          Padding(
            padding: const EdgeInsets.only(bottom: 8.0),
            child: DateFilterField(
              label: _translateFilterLabel(key),
              value: _filters[key]?.toString(),
              onChanged: (v) {
                if (v == null || v.isEmpty) {
                  _filters.remove(key);
                } else {
                  _filters[key] = v;
                }
              },
            ),
          ),
        );
      } else if (isCobrador || isCliente || isCategoria) {
        // Usar search-select para estos campos: guardamos el id o texto seleccionado
        widgets.add(
          Padding(
            padding: const EdgeInsets.only(bottom: 8.0),
            child: SearchSelectField(
              label: _translateFilterLabel(key),
              initialValue: _filters[key]?.toString(),
              // Tipo usado para decidir qu√© provider/endpoint usar internamente
              type: isCobrador
                  ? 'cobrador'
                  : (isCliente ? 'cliente' : 'categoria'),
              onSelected: (id, label) {
                // Guardar el id si viene, sino el label
                _filters[key] = id ?? label;
              },
            ),
          ),
        );
      } else {
        widgets.add(
          Padding(
            padding: const EdgeInsets.only(bottom: 8.0),
            child: TextFormField(
              decoration: InputDecoration(
                labelText: _translateFilterLabel(key),
                border: const OutlineInputBorder(),
              ),
              onChanged: (v) => _filters[key] = v,
            ),
          ),
        );
      }
    }

    return widgets;
  }

  void _generateReport() {
    // Construir y fijar la petici√≥n actual; esto evita ejecuciones autom√°ticas del provider
    setState(() {
      _currentRequest = rp.ReportRequest(
        type: _selectedReport ?? '',
        filters: Map<String, dynamic>.from(_filters),
        format: _format,
      );
    });
  }

  void _clearFilters() {
    setState(() {
      _filters.clear();
      _quickRangeIndex = null;
    });
    ScaffoldMessenger.of(
      context,
    ).showSnackBar(const SnackBar(content: Text('Filtros limpiados')));
  }
}

Widget buildTableFromJson(
  List<Map<String, dynamic>> rows, {
  List<String>? columnOrder,
}) {
  // Determinar conjunto de columnas (union de claves) y respetar orden preferido
  final keys = <String>{};
  for (final r in rows) {
    keys.addAll(r.keys.map((k) => k.toString()));
  }

  List<String> columns;
  if (columnOrder != null && columnOrder.isNotEmpty) {
    // Mantener s√≥lo las columnas que existen en los datos, en el orden pedido
    columns = columnOrder.where((c) => keys.contains(c)).toList();
    // A√±adir columnas extra (no solicitadas) al final, ordenadas alfabeticamente
    final extras = keys.difference(columns.toSet()).toList()..sort();
    columns.addAll(extras);
  } else {
    columns = keys.toList()..sort();
  }

  // Definir anchos de columna (por √≠ndice) con heur√≠stica simple
  final columnWidths = <int, TableColumnWidth>{};
  for (int i = 0; i < columns.length; i++) {
    final name = columns[i].toLowerCase();
    if (name == 'id') {
      columnWidths[i] = const FixedColumnWidth(70);
    } else if (name.contains('fecha') || name.contains('date')) {
      columnWidths[i] = const FixedColumnWidth(130);
    } else if (name.contains('monto') || name.contains('amount')) {
      columnWidths[i] = const FixedColumnWidth(120);
    } else {
      columnWidths[i] = const IntrinsicColumnWidth();
    }
  }

  return Table(
    columnWidths: columnWidths,
    border: TableBorder.all(color: Colors.grey.shade300),
    defaultVerticalAlignment: TableCellVerticalAlignment.middle,
    children: [
      // Fila de encabezado
      TableRow(
        decoration: BoxDecoration(color: Colors.grey.shade100),
        children: columns
            .map(
              (c) => TableCell(
                child: Padding(
                  padding: const EdgeInsets.all(12.0),
                  child: Text(
                    c,
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 15,
                    ),
                    textAlign: TextAlign.center,
                  ),
                ),
              ),
            )
            .toList(),
      ),
      // Filas de datos
      ...rows
          .map(
            (r) => TableRow(
              children: columns
                  .map(
                    (c) => TableCell(
                      child: Padding(
                        padding: const EdgeInsets.all(12.0),
                        child: Text(
                          r[c]?.toString() ?? '',
                          textAlign: TextAlign.center,
                          style: const TextStyle(fontSize: 14),
                        ),
                      ),
                    ),
                  )
                  .toList(),
            ),
          )
          .toList(),
    ],
  );
}

Widget buildTableFromMap(Map<String, dynamic> map) {
  final entries = map.entries.toList();

  return Table(
    columnWidths: const {0: IntrinsicColumnWidth(), 1: IntrinsicColumnWidth()},
    border: TableBorder.all(color: Colors.grey.shade300),
    defaultVerticalAlignment: TableCellVerticalAlignment.middle,
    children: [
      TableRow(
        decoration: BoxDecoration(color: Colors.grey.shade100),
        children: [
          TableCell(
            child: Padding(
              padding: const EdgeInsets.all(12.0),
              child: Text(
                'Campo',
                style: TextStyle(fontWeight: FontWeight.bold, fontSize: 15),
                textAlign: TextAlign.center,
              ),
            ),
          ),
          TableCell(
            child: Padding(
              padding: const EdgeInsets.all(12.0),
              child: Text(
                'Valor',
                style: TextStyle(fontWeight: FontWeight.bold, fontSize: 15),
                textAlign: TextAlign.center,
              ),
            ),
          ),
        ],
      ),
      ...entries
          .map(
            (e) => TableRow(
              children: [
                TableCell(
                  child: Padding(
                    padding: const EdgeInsets.all(12.0),
                    child: Text(
                      e.key,
                      textAlign: TextAlign.center,
                      style: const TextStyle(fontSize: 14),
                    ),
                  ),
                ),
                TableCell(
                  child: Padding(
                    padding: const EdgeInsets.all(12.0),
                    child: Text(
                      e.value?.toString() ?? '',
                      textAlign: TextAlign.center,
                      style: const TextStyle(fontSize: 14),
                    ),
                  ),
                ),
              ],
            ),
          )
          .toList(),
    ],
  );
}



// ==========================
// Vista de Cr√©ditos: helpers y cards (movidas arriba para evitar referencias hacia adelante)
// ==========================

double _toDouble(dynamic val) {
  if (val == null) return 0.0;
  if (val is num) return val.toDouble();
  return double.tryParse(val.toString()) ?? 0.0;
}


Widget buildCreditsList(
  List<Map<String, dynamic>> credits,
  BuildContext context,
) {
  double _sumTotalAmount() {
    double total = 0.0;
    for (final cr in credits) {
      total += _toDouble(cr['total_amount']);
    }
    return total;
  }

  final total = _sumTotalAmount();
  final totalStr = ReportFormatters.formatCurrency(total);

  return Column(
    crossAxisAlignment: CrossAxisAlignment.start,
    children: [
      Row(
        children: [
          const Icon(Icons.assignment, color: Colors.indigo),
          const SizedBox(width: 8),
          Text(
            'Cr√©ditos',
            style: Theme.of(
              context,
            ).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
          ),
          const SizedBox(width: 8),
          Chip(
            label: Text('${credits.length}'),
            backgroundColor: Colors.indigo.withOpacity(0.08),
            side: BorderSide(color: Colors.indigo.withOpacity(0.2)),
          ),
          const Spacer(),
          Text(
            totalStr,
            style: Theme.of(context).textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
              color: Colors.green,
            ),
          ),
        ],
      ),
      const SizedBox(height: 8),
      ListView.separated(
        shrinkWrap: true,
        physics: const NeverScrollableScrollPhysics(),
        itemCount: credits.length,
        separatorBuilder: (_, __) => const SizedBox(height: 8),
        itemBuilder: (ctx, i) {
          final cr = credits[i];
          final clientName = ReportFormatters.extractCreditClientName(cr);
          final cobradorName = ReportFormatters.extractCreditCobradorName(cr);
          final status = cr['status']?.toString();
          final freq = cr['frequency']?.toString();
          final totalAmount = _toDouble(cr['total_amount']);
          final balance = _toDouble(cr['balance']);
          final paid = (totalAmount - balance).clamp(0, totalAmount);
          final pct = totalAmount > 0 ? (paid / totalAmount) : 0.0;
          final statusColor = ReportFormatters.colorForCreditStatus(status);
          final freqColor = ReportFormatters.colorForFrequency(freq);

          return Card(
            elevation: 1,
            child: ListTile(
              leading: CircleAvatar(
                backgroundColor: statusColor.withOpacity(0.12),
                foregroundColor: statusColor,
                child: const Icon(Icons.account_balance_wallet),
              ),
              title: Text(
                clientName,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
                style: const TextStyle(fontWeight: FontWeight.w600),
              ),
              subtitle: Padding(
                padding: const EdgeInsets.only(top: 6.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Wrap(
                      spacing: 6,
                      runSpacing: 4,
                      children: [
                        Chip(
                          label: Text((status ?? '').toUpperCase()),
                          backgroundColor: statusColor.withOpacity(0.08),
                          side: BorderSide(color: statusColor.withOpacity(0.2)),
                          visualDensity: VisualDensity.compact,
                          materialTapTargetSize:
                              MaterialTapTargetSize.shrinkWrap,
                        ),
                        if (freq != null && freq.isNotEmpty)
                          Chip(
                            label: Text((freq).toUpperCase()),
                            backgroundColor: freqColor.withOpacity(0.08),
                            side: BorderSide(color: freqColor.withOpacity(0.2)),
                            visualDensity: VisualDensity.compact,
                            materialTapTargetSize:
                                MaterialTapTargetSize.shrinkWrap,
                          ),
                        if (cr['created_at'] != null)
                          Chip(
                            avatar: const Icon(Icons.event, size: 16),
                            label: Text(ReportFormatters.formatDate(cr['created_at'])),
                            backgroundColor: Colors.grey.withOpacity(0.08),
                            side: BorderSide(
                              color: Colors.grey.withOpacity(0.2),
                            ),
                            visualDensity: VisualDensity.compact,
                            materialTapTargetSize:
                                MaterialTapTargetSize.shrinkWrap,
                          ),
                        if (cr['end_date'] != null)
                          Chip(
                            avatar: const Icon(Icons.flag, size: 16),
                            label: Text(ReportFormatters.formatDate(cr['end_date'])),
                            backgroundColor: Colors.grey.withOpacity(0.08),
                            side: BorderSide(
                              color: Colors.grey.withOpacity(0.2),
                            ),
                            visualDensity: VisualDensity.compact,
                            materialTapTargetSize:
                                MaterialTapTargetSize.shrinkWrap,
                          ),
                      ],
                    ),
                    const SizedBox(height: 6),
                    ClipRRect(
                      borderRadius: BorderRadius.circular(4),
                      child: LinearProgressIndicator(
                        value: pct,
                        minHeight: 6,
                        backgroundColor: Colors.grey.shade200,
                        color: statusColor,
                      ),
                    ),
                  ],
                ),
              ),
              trailing: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Text(
                    ReportFormatters.formatCurrency(balance),
                    style: const TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.bold,
                      color: Colors.orange,
                    ),
                  ),
                  SizedBox(
                    width: 140,
                    child: Text(
                      'Saldo',
                      textAlign: TextAlign.right,
                      style: const TextStyle(fontSize: 11, color: Colors.grey),
                    ),
                  ),
                  const SizedBox(height: 4),
                  SizedBox(
                    width: 140,
                    child: Text(
                      'Total: ${ReportFormatters.formatCurrency(totalAmount)}',
                      textAlign: TextAlign.right,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: const TextStyle(fontSize: 11, color: Colors.grey),
                    ),
                  ),
                  if (cobradorName.isNotEmpty)
                    SizedBox(
                      width: 140,
                      child: Text(
                        cobradorName,
                        maxLines: 1,
                        textAlign: TextAlign.right,
                        overflow: TextOverflow.ellipsis,
                        style: const TextStyle(
                          fontSize: 11,
                          color: Colors.grey,
                        ),
                      ),
                    ),
                ],
              ),
            ),
          );
        },
      ),
    ],
  );
}

// ==========================
// Vista de Balances: helpers y cards
// ==========================
Color _diffColor(double diff) {
  final ad = diff.abs();
  if (ad < 0.01) return Colors.blueGrey; // casi cero
  return diff >= 0 ? Colors.green : Colors.red;
}

double _numVal(dynamic v) {
  if (v == null) return 0.0;
  if (v is num) return v.toDouble();
  return double.tryParse(v.toString()) ?? 0.0;
}


// Obtiene un valor num√©rico usando m√∫ltiples posibles nombres de campo
double _pickAmount(Map<String, dynamic> b, List<String> keys) {
  for (final k in keys) {
    if (b.containsKey(k) && b[k] != null) return _numVal(b[k]);
  }
  return 0.0;
}

// Intenta obtener diferencia; si no existe, la estima: final - (initial + collected - lent)
double _computeBalanceDiff(Map<String, dynamic> b) {
  if (b['difference'] != null) return _numVal(b['difference']);
  if (b['diff'] != null) return _numVal(b['diff']);
  final initial = _pickAmount(b, [
    'initial',
    'initial_amount',
    'start',
    'opening',
    'initial_cash',
  ]);
  final collected = _pickAmount(b, [
    'collected',
    'collected_amount',
    'income',
    'in',
  ]);
  final lent = _pickAmount(b, ['lent', 'lent_amount', 'loaned', 'out']);
  final finalVal = _pickAmount(b, ['final', 'final_amount', 'closing', 'end']);
  return finalVal - (initial + collected - lent);
}

Widget buildBalancesList(
  List<Map<String, dynamic>> balances,
  BuildContext context,
) {
  double _sumFinal() {
    double total = 0.0;
    for (final b in balances) {
      total += _pickAmount(b, ['final', 'final_amount', 'closing', 'end']);
    }
    return total;
  }

  final totalFinal = _sumFinal();
  final totalFinalStr = ReportFormatters.formatCurrency(totalFinal);

  return Column(
    crossAxisAlignment: CrossAxisAlignment.start,
    children: [
      Row(
        children: [
          const Icon(Icons.account_balance, color: Colors.indigo),
          const SizedBox(width: 8),
          Text(
            'Balances de caja',
            style: Theme.of(
              context,
            ).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
          ),
          const SizedBox(width: 8),
          Chip(
            label: Text('${balances.length}'),
            backgroundColor: Colors.indigo.withOpacity(0.08),
            side: BorderSide(color: Colors.indigo.withOpacity(0.2)),
          ),
          const Spacer(),
          Text(
            totalFinalStr,
            style: Theme.of(context).textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
              color: Colors.green,
            ),
          ),
        ],
      ),
      const SizedBox(height: 8),
      ListView.separated(
        shrinkWrap: true,
        physics: const NeverScrollableScrollPhysics(),
        itemCount: balances.length,
        separatorBuilder: (_, __) => const SizedBox(height: 8),
        itemBuilder: (ctx, i) {
          final b = balances[i];
          final cobrador = ReportFormatters.extractBalanceCobradorName(b);
          final dateStr = ReportFormatters.extractBalanceDate(b);
          final initial = _pickAmount(b, [
            'initial',
            'initial_amount',
            'opening',
          ]);
          final collected = _pickAmount(b, [
            'collected',
            'collected_amount',
            'income',
          ]);
          final lent = _pickAmount(b, ['lent', 'lent_amount', 'loaned']);
          final finalVal = _pickAmount(b, ['final', 'final_amount', 'closing']);
          final diff = _computeBalanceDiff(b);
          final diffClr = _diffColor(diff);

          return Card(
            elevation: 1,
            child: ListTile(
              leading: CircleAvatar(
                backgroundColor: diffClr.withOpacity(0.12),
                foregroundColor: diffClr,
                child: const Icon(Icons.calculate),
              ),
              title: Text(
                dateStr.isNotEmpty ? dateStr : 'Balance',
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
                style: const TextStyle(fontWeight: FontWeight.w600),
              ),
              subtitle: Padding(
                padding: const EdgeInsets.only(top: 6.0),
                child: Wrap(
                  spacing: 6,
                  runSpacing: 4,
                  crossAxisAlignment: WrapCrossAlignment.center,
                  children: [
                    Chip(
                      avatar: const Icon(Icons.start, size: 16),
                      label: Text(ReportFormatters.formatCurrency(initial)),
                      backgroundColor: Colors.blueGrey.withOpacity(0.08),
                      side: BorderSide(color: Colors.blueGrey.withOpacity(0.2)),
                      visualDensity: VisualDensity.compact,
                      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                    ),
                    Chip(
                      avatar: const Icon(Icons.call_received, size: 16),
                      label: Text('Recaudado ${ReportFormatters.formatCurrency(collected)}'),
                      backgroundColor: Colors.green.withOpacity(0.08),
                      side: BorderSide(color: Colors.green.withOpacity(0.2)),
                      visualDensity: VisualDensity.compact,
                      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                    ),
                    Chip(
                      avatar: const Icon(Icons.call_made, size: 16),
                      label: Text('Prestado ${ReportFormatters.formatCurrency(lent)}'),
                      backgroundColor: Colors.orange.withOpacity(0.08),
                      side: BorderSide(color: Colors.orange.withOpacity(0.2)),
                      visualDensity: VisualDensity.compact,
                      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                    ),
                    if (cobrador.isNotEmpty)
                      Chip(
                        avatar: const Icon(Icons.person, size: 16),
                        label: Text(cobrador),
                        backgroundColor: Colors.grey.withOpacity(0.08),
                        side: BorderSide(color: Colors.grey.withOpacity(0.2)),
                        visualDensity: VisualDensity.compact,
                        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                      ),
                  ],
                ),
              ),
              trailing: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Text(
                    ReportFormatters.formatCurrency(finalVal),
                    style: const TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.bold,
                      color: Colors.indigo,
                    ),
                  ),
                  SizedBox(
                    width: 140,
                    child: Text(
                      'Final',
                      textAlign: TextAlign.right,
                      style: const TextStyle(fontSize: 11, color: Colors.grey),
                    ),
                  ),
                  const SizedBox(height: 4),
                  SizedBox(
                    width: 140,
                    child: Text(
                      'Dif: ${ReportFormatters.formatCurrency(diff)}',
                      textAlign: TextAlign.right,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(fontSize: 12, color: diffClr),
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    ],
  );
}

class _ReportResultView extends ConsumerWidget {
  final rp.ReportRequest? request;

  const _ReportResultView({required this.request, Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    if (request == null) {
      return const Center(
        child: Text('Seleccione un reporte y presione Generar'),
      );
    }

    final req = request!;
    if (req.type.isEmpty) {
      return const Center(
        child: Text('Seleccione un reporte y presione Generar'),
      );
    }

    final asyncVal = ref.watch(generateReportProvider(req));

    return asyncVal.when(
      data: (value) {
        if (req.format == 'json') {
          // Intentar mostrar JSON como tabla si es una lista de objetos o tiene 'data' con lista
          final dynamic payload = value is Map && value.containsKey('data')
              ? value['data']
              : value;

          if (payload is Map && payload.containsKey('payments')) {
            final payments = payload['payments'];
            if (payments is List &&
                payments.isNotEmpty &&
                payments.first is Map) {
              // Aplanar y formatear cada payment a un Map con columnas legibles
              final List<Map<String, dynamic>> rows = payments
                  .map<Map<String, dynamic>>((p) {
                    final Map<String, dynamic> pm = Map<String, dynamic>.from(
                      p as Map,
                    );
                    final cobrador = pm['cobrador'] is Map
                        ? pm['cobrador']['name']
                        : pm['cobrador']?.toString();

                    // Extraer nombre del cliente desde varios posibles lugares
                    String? clientName;
                    if (pm['client'] is Map && pm['client']['name'] != null) {
                      clientName = pm['client']['name'].toString();
                    } else if (pm['credit'] is Map) {
                      final credit = pm['credit'] as Map;
                      if (credit['client'] is Map &&
                          credit['client']['name'] != null) {
                        clientName = credit['client']['name'].toString();
                      } else if (credit['client_name'] != null) {
                        clientName = credit['client_name'].toString();
                      }
                    } else if (pm['client_name'] != null) {
                      clientName = pm['client_name'].toString();
                    }

                    final cuota = pm['installment_number']?.toString() ?? '';

                    return {
                      'ID': pm['id']?.toString() ?? '',
                      'Fecha': ReportFormatters.formatDate(pm['payment_date']),
                      'Cobrador': cobrador?.toString() ?? '',
                      'Cliente': clientName ?? '',
                      'Monto': ReportFormatters.formatCurrency(pm['amount']),
                      'Cuota': cuota,
                      'Tipo': pm['payment_method']?.toString() ?? '',
                      'Notas': pm['status']?.toString() ?? '',
                    };
                  })
                  .toList();

              final columnsOrder = [
                'ID',
                'Fecha',
                'Cuota',
                'Cobrador',
                'Cliente',
                'Monto',
                'Tipo',
                'Notas',
              ];

              final Map<String, dynamic> summary = (payload['summary'] is Map)
                  ? Map<String, dynamic>.from(payload['summary'] as Map)
                  : <String, dynamic>{};

              // Detectar si el rango corresponde a HOY (para vista especial)
              final String _todayStr = DateTime.now()
                  .toIso8601String()
                  .split('T')
                  .first;
              final String? _fStart = req.filters?['start_date']?.toString();
              final String? _fEnd = req.filters?['end_date']?.toString();
              final bool isTodayRange =
                  (_fStart == _todayStr && _fEnd == _todayStr) ||
                  ((summary['date_range'] is Map) &&
                      (summary['date_range']['start']?.toString() ==
                          _todayStr) &&
                      (summary['date_range']['end']?.toString() == _todayStr));
              final List<Map<String, dynamic>> typedPayments =
                  (payments is List)
                  ? (payments as List)
                        .whereType<Map>()
                        .map<Map<String, dynamic>>(
                          (e) => Map<String, dynamic>.from(e as Map),
                        )
                        .toList()
                  : <Map<String, dynamic>>[];

              return SingleChildScrollView(
                padding: const EdgeInsets.all(8.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Acciones r√°pidas de descarga
                    Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Flexible(
                          child: Wrap(
                            spacing: 8,
                            runSpacing: 8,
                            children: [
                              ElevatedButton.icon(
                                onPressed: () async {
                                  try {
                                    final bytes = await ref
                                        .read(rp.reportsApiProvider)
                                        .generateReport(
                                          req.type,
                                          filters: req.filters,
                                          format: 'excel',
                                        );
                                    if (bytes is List<int>) {
                                      final dir =
                                          await getApplicationDocumentsDirectory();
                                      final ts = DateTime.now()
                                          .toIso8601String()
                                          .replaceAll(':', '-');
                                      final fileName =
                                          'reporte_${req.type}_$ts.xlsx';
                                      final file = File(
                                        '${dir.path}/$fileName',
                                      );
                                      await file.writeAsBytes(bytes);
                                      ScaffoldMessenger.of(
                                        context,
                                      ).showSnackBar(
                                        SnackBar(
                                          content: Text(
                                            'Reporte guardado: $fileName',
                                          ),
                                          action: SnackBarAction(
                                            label: 'Abrir',
                                            onPressed: () {
                                              OpenFilex.open(file.path);
                                            },
                                          ),
                                        ),
                                      );
                                      try {
                                        await OpenFilex.open(file.path);
                                      } catch (_) {}
                                    }
                                  } catch (e) {
                                    ScaffoldMessenger.of(context).showSnackBar(
                                      SnackBar(
                                        content: Text(
                                          'Error al descargar Excel: $e',
                                        ),
                                      ),
                                    );
                                  }
                                },
                                icon: const Icon(Icons.grid_on),
                                label: const Text('Excel'),
                              ),
                              ElevatedButton.icon(
                                onPressed: () async {
                                  try {
                                    final bytes = await ref
                                        .read(rp.reportsApiProvider)
                                        .generateReport(
                                          req.type,
                                          filters: req.filters,
                                          format: 'pdf',
                                        );
                                    if (bytes is List<int>) {
                                      final dir =
                                          await getApplicationDocumentsDirectory();
                                      final ts = DateTime.now()
                                          .toIso8601String()
                                          .replaceAll(':', '-');
                                      final fileName =
                                          'reporte_${req.type}_$ts.pdf';
                                      final file = File(
                                        '${dir.path}/$fileName',
                                      );
                                      await file.writeAsBytes(bytes);
                                      ScaffoldMessenger.of(
                                        context,
                                      ).showSnackBar(
                                        SnackBar(
                                          content: Text(
                                            'Reporte guardado: $fileName',
                                          ),
                                          action: SnackBarAction(
                                            label: 'Abrir',
                                            onPressed: () {
                                              OpenFilex.open(file.path);
                                            },
                                          ),
                                        ),
                                      );
                                      try {
                                        await OpenFilex.open(file.path);
                                      } catch (_) {}
                                    }
                                  } catch (e) {
                                    ScaffoldMessenger.of(context).showSnackBar(
                                      SnackBar(
                                        content: Text(
                                          'Error al descargar PDF: $e',
                                        ),
                                      ),
                                    );
                                  }
                                },
                                icon: const Icon(Icons.picture_as_pdf),
                                label: const Text('PDF'),
                              ),
                            ],
                          ),
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Align(
                            alignment: Alignment.centerRight,
                            child:
                                (payload['generated_by'] != null ||
                                    payload['generated_at'] != null)
                                ? Text(
                                    'Generado' +
                                        (payload['generated_by'] != null
                                            ? ' por ${payload['generated_by']}'
                                            : '') +
                                        (payload['generated_at'] != null
                                            ? ' ‚Ä¢ ${ReportFormatters.formatDate(payload['generated_at'])}'
                                            : ''),
                                    style: Theme.of(
                                      context,
                                    ).textTheme.bodySmall,
                                    overflow: TextOverflow.ellipsis,
                                    maxLines: 1,
                                  )
                                : const SizedBox.shrink(),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),
                    if (summary.isNotEmpty)
                      Wrap(
                        spacing: 8,
                        runSpacing: 8,
                        children: [
                          MiniStatCard(
                            title: 'Pagos',
                            value: '${summary['total_payments'] ?? 0}',
                            icon: Icons.receipt_long,
                            color: Colors.indigo,
                          ),
                          MiniStatCard(
                            title: 'Monto total',
                            value: ReportFormatters.formatCurrency(
                              summary['total_amount'] ?? 0,
                            ),
                            icon: Icons.attach_money,
                            color: Colors.green,
                          ),
                          MiniStatCard(
                            title: 'Promedio',
                            value: ReportFormatters.formatCurrency(
                              summary['average_payment'] ?? 0,
                            ),
                            icon: Icons.calculate,
                            color: Colors.orange,
                          ),
                          if (summary['date_range'] is Map)
                            MiniStatCard(
                              title: 'Rango',
                              value:
                                  '${summary['date_range']['start'] ?? ''} ‚Üí ${summary['date_range']['end'] ?? ''}',
                              icon: Icons.date_range,
                              color: Colors.blueGrey,
                            ),
                        ],
                      ),
                    const SizedBox(height: 12),
                    if (isTodayRange && typedPayments.isNotEmpty) ...[
                      buildTodayPaymentsList(typedPayments, context),
                      const SizedBox(height: 12),
                    ],
                    SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: buildTableFromJson(
                        rows,
                        columnOrder: columnsOrder,
                      ),
                    ),
                  ],
                ),
              );
            }
          } else if (payload is Map && payload.containsKey('credits')) {
            final credits = payload['credits'];
            if (credits is List && credits.isNotEmpty && credits.first is Map) {
              // Aplanar y formatear cada cr√©dito a un Map con columnas legibles
              final List<Map<String, dynamic>> rows = credits
                  .map<Map<String, dynamic>>((c) {
                    final Map<String, dynamic> cr = Map<String, dynamic>.from(
                      c as Map,
                    );

                    String clientName = '';
                    try {
                      if (cr['client'] is Map && cr['client']['name'] != null) {
                        clientName = cr['client']['name'].toString();
                      } else if (cr['client_name'] != null) {
                        clientName = cr['client_name'].toString();
                      }
                    } catch (_) {}

                    String cobradorName = '';
                    try {
                      if (cr['cobrador'] is Map &&
                          cr['cobrador']['name'] != null) {
                        cobradorName = cr['cobrador']['name'].toString();
                      } else if (cr['cobrador_name'] != null) {
                        cobradorName = cr['cobrador_name'].toString();
                      }
                    } catch (_) {}

                    return {
                      'ID': cr['id']?.toString() ?? '',
                      'Cliente': clientName,
                      'Cobrador': cobradorName,
                      'Estado': cr['status']?.toString() ?? '',
                      'Frecuencia': cr['frequency']?.toString() ?? '',
                      'Monto': ReportFormatters.formatCurrency(cr['amount']),
                      'Total': ReportFormatters.formatCurrency(cr['total_amount']),
                      'Saldo': ReportFormatters.formatCurrency(cr['balance']),
                      'Creaci√≥n': ReportFormatters.formatDate(cr['created_at']),
                      'Vencimiento': ReportFormatters.formatDate(cr['end_date']),
                    };
                  })
                  .toList();

              final columnsOrder = [
                'ID',
                'Cliente',
                'Cobrador',
                'Estado',
                'Frecuencia',
                'Monto',
                'Total',
                'Saldo',
                'Creaci√≥n',
                'Vencimiento',
              ];

              final Map<String, dynamic> summary = (payload['summary'] is Map)
                  ? Map<String, dynamic>.from(payload['summary'] as Map)
                  : <String, dynamic>{};

              final List<Map<String, dynamic>> typedCredits = (credits is List)
                  ? (credits as List)
                        .whereType<Map>()
                        .map<Map<String, dynamic>>(
                          (e) => Map<String, dynamic>.from(e as Map),
                        )
                        .toList()
                  : <Map<String, dynamic>>[];

              return SingleChildScrollView(
                padding: const EdgeInsets.all(8.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Acciones r√°pidas de descarga
                    Row(
                      children: [
                        ElevatedButton.icon(
                          onPressed: () async {
                            try {
                              final bytes = await ref
                                  .read(rp.reportsApiProvider)
                                  .generateReport(
                                    req.type,
                                    filters: req.filters,
                                    format: 'excel',
                                  );
                              if (bytes is List<int>) {
                                final dir =
                                    await getApplicationDocumentsDirectory();
                                final ts = DateTime.now()
                                    .toIso8601String()
                                    .replaceAll(':', '-');
                                final fileName = 'reporte_${req.type}_$ts.xlsx';
                                final file = File('${dir.path}/$fileName');
                                await file.writeAsBytes(bytes);
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text(
                                      'Reporte guardado: $fileName',
                                    ),
                                    action: SnackBarAction(
                                      label: 'Abrir',
                                      onPressed: () {
                                        OpenFilex.open(file.path);
                                      },
                                    ),
                                  ),
                                );
                                try {
                                  await OpenFilex.open(file.path);
                                } catch (_) {}
                              }
                            } catch (e) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text('Error al descargar Excel: $e'),
                                ),
                              );
                            }
                          },
                          icon: const Icon(Icons.grid_on),
                          label: const Text('Excel'),
                        ),
                        const SizedBox(width: 8),
                        ElevatedButton.icon(
                          onPressed: () async {
                            try {
                              final bytes = await ref
                                  .read(rp.reportsApiProvider)
                                  .generateReport(
                                    req.type,
                                    filters: req.filters,
                                    format: 'pdf',
                                  );
                              if (bytes is List<int>) {
                                final dir =
                                    await getApplicationDocumentsDirectory();
                                final ts = DateTime.now()
                                    .toIso8601String()
                                    .replaceAll(':', '-');
                                final fileName = 'reporte_${req.type}_$ts.pdf';
                                final file = File('${dir.path}/$fileName');
                                await file.writeAsBytes(bytes);
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text(
                                      'Reporte guardado: $fileName',
                                    ),
                                    action: SnackBarAction(
                                      label: 'Abrir',
                                      onPressed: () {
                                        OpenFilex.open(file.path);
                                      },
                                    ),
                                  ),
                                );
                                try {
                                  await OpenFilex.open(file.path);
                                } catch (_) {}
                              }
                            } catch (e) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text('Error al descargar PDF: $e'),
                                ),
                              );
                            }
                          },
                          icon: const Icon(Icons.picture_as_pdf),
                          label: const Text('PDF'),
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Align(
                            alignment: Alignment.centerRight,
                            child:
                                (payload['generated_by'] != null ||
                                    payload['generated_at'] != null)
                                ? Text(
                                    'Generado' +
                                        (payload['generated_by'] != null
                                            ? ' por ${payload['generated_by']}'
                                            : '') +
                                        (payload['generated_at'] != null
                                            ? ' ‚Ä¢ ${ReportFormatters.formatDate(payload['generated_at'])}'
                                            : ''),
                                    style: Theme.of(
                                      context,
                                    ).textTheme.bodySmall,
                                    overflow: TextOverflow.ellipsis,
                                    maxLines: 1,
                                  )
                                : const SizedBox.shrink(),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),
                    if (summary.isNotEmpty)
                      Wrap(
                        spacing: 8,
                        runSpacing: 8,
                        children: [
                          MiniStatCard(
                            title: 'Cr√©ditos',
                            value: '${summary['total_credits'] ?? 0}',
                            icon: Icons.assignment,
                            color: Colors.indigo,
                          ),
                          MiniStatCard(
                            title: 'Monto total',
                            value: ReportFormatters.formatCurrency(
                              summary['total_amount'] ?? 0,
                            ),
                            icon: Icons.attach_money,
                            color: Colors.green,
                          ),
                          MiniStatCard(
                            title: 'Activos',
                            value: '${summary['active_credits'] ?? 0}',
                            icon: Icons.play_circle_fill,
                            color: Colors.blue,
                          ),
                          MiniStatCard(
                            title: 'Completados',
                            value: '${summary['completed_credits'] ?? 0}',
                            icon: Icons.check_circle,
                            color: Colors.teal,
                          ),
                          MiniStatCard(
                            title: 'Saldo total',
                            value: ReportFormatters.formatCurrency(
                              summary['total_balance'] ?? 0,
                            ),
                            icon: Icons.account_balance_wallet,
                            color: Colors.orange,
                          ),
                          MiniStatCard(
                            title: 'Pendiente',
                            value: ReportFormatters.formatCurrency(
                              summary['pending_amount'] ?? 0,
                            ),
                            icon: Icons.warning,
                            color: Colors.deepOrange,
                          ),
                        ],
                      ),
                    const SizedBox(height: 12),
                    if (typedCredits.isNotEmpty) ...[
                      buildCreditsList(typedCredits, context),
                      const SizedBox(height: 12),
                    ],
                    SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: buildTableFromJson(
                        rows,
                        columnOrder: columnsOrder,
                      ),
                    ),
                  ],
                ),
              );
            }
          } else if (payload is Map && payload.containsKey('balances')) {
            final balances = payload['balances'];
            if (balances is List &&
                balances.isNotEmpty &&
                balances.first is Map) {
              final List<Map<String, dynamic>> typedBalances =
                  (balances as List)
                      .whereType<Map>()
                      .map<Map<String, dynamic>>(
                        (e) => Map<String, dynamic>.from(e as Map),
                      )
                      .toList();

              // Construir filas legibles para la tabla
              final List<Map<String, dynamic>> rows = typedBalances.map((b) {
                final cobrador = ReportFormatters.extractBalanceCobradorName(b);
                final fecha = ReportFormatters.extractBalanceDate(b);
                final inicial = _pickAmount(b, [
                  'initial',
                  'initial_amount',
                  'opening',
                ]);
                final recaudado = _pickAmount(b, [
                  'collected',
                  'collected_amount',
                  'income',
                ]);
                final prestado = _pickAmount(b, [
                  'lent',
                  'lent_amount',
                  'loaned',
                ]);
                final finalVal = _pickAmount(b, [
                  'final',
                  'final_amount',
                  'closing',
                ]);
                final diferencia = _computeBalanceDiff(b);
                final notas = (b['notes'] ?? b['description'] ?? '').toString();

                return {
                  'Fecha': fecha,
                  'Cobrador': cobrador,
                  'Inicial': ReportFormatters.formatCurrency(inicial),
                  'Recaudado': ReportFormatters.formatCurrency(recaudado),
                  'Prestado': ReportFormatters.formatCurrency(prestado),
                  'Final': ReportFormatters.formatCurrency(finalVal),
                  'Diferencia': ReportFormatters.formatCurrency(diferencia),
                  'Notas': notas,
                };
              }).toList();

              final columnsOrder = [
                'Fecha',
                'Cobrador',
                'Inicial',
                'Recaudado',
                'Prestado',
                'Final',
                'Diferencia',
                'Notas',
              ];

              final Map<String, dynamic> summary = (payload['summary'] is Map)
                  ? Map<String, dynamic>.from(payload['summary'] as Map)
                  : <String, dynamic>{};

              return SingleChildScrollView(
                padding: const EdgeInsets.all(8.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Acciones r√°pidas de descarga
                    Row(
                      children: [
                        ElevatedButton.icon(
                          onPressed: () async {
                            try {
                              final bytes = await ref
                                  .read(rp.reportsApiProvider)
                                  .generateReport(
                                    req.type,
                                    filters: req.filters,
                                    format: 'excel',
                                  );
                              if (bytes is List<int>) {
                                final dir =
                                    await getApplicationDocumentsDirectory();
                                final ts = DateTime.now()
                                    .toIso8601String()
                                    .replaceAll(':', '-');
                                final fileName = 'reporte_${req.type}_$ts.xlsx';
                                final file = File('${dir.path}/$fileName');
                                await file.writeAsBytes(bytes);
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text(
                                      'Reporte guardado: $fileName',
                                    ),
                                    action: SnackBarAction(
                                      label: 'Abrir',
                                      onPressed: () {
                                        OpenFilex.open(file.path);
                                      },
                                    ),
                                  ),
                                );
                                try {
                                  await OpenFilex.open(file.path);
                                } catch (_) {}
                              }
                            } catch (e) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text('Error al descargar Excel: $e'),
                                ),
                              );
                            }
                          },
                          icon: const Icon(Icons.grid_on),
                          label: const Text('Excel'),
                        ),
                        const SizedBox(width: 8),
                        ElevatedButton.icon(
                          onPressed: () async {
                            try {
                              final bytes = await ref
                                  .read(rp.reportsApiProvider)
                                  .generateReport(
                                    req.type,
                                    filters: req.filters,
                                    format: 'pdf',
                                  );
                              if (bytes is List<int>) {
                                final dir =
                                    await getApplicationDocumentsDirectory();
                                final ts = DateTime.now()
                                    .toIso8601String()
                                    .replaceAll(':', '-');
                                final fileName = 'reporte_${req.type}_$ts.pdf';
                                final file = File('${dir.path}/$fileName');
                                await file.writeAsBytes(bytes);
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text(
                                      'Reporte guardado: $fileName',
                                    ),
                                    action: SnackBarAction(
                                      label: 'Abrir',
                                      onPressed: () {
                                        OpenFilex.open(file.path);
                                      },
                                    ),
                                  ),
                                );
                                try {
                                  await OpenFilex.open(file.path);
                                } catch (_) {}
                              }
                            } catch (e) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text('Error al descargar PDF: $e'),
                                ),
                              );
                            }
                          },
                          icon: const Icon(Icons.picture_as_pdf),
                          label: const Text('PDF'),
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Align(
                            alignment: Alignment.centerRight,
                            child:
                                (payload['generated_by'] != null ||
                                    payload['generated_at'] != null)
                                ? Text(
                                    'Generado' +
                                        (payload['generated_by'] != null
                                            ? ' por ${payload['generated_by']}'
                                            : '') +
                                        (payload['generated_at'] != null
                                            ? ' ‚Ä¢ ${ReportFormatters.formatDate(payload['generated_at'])}'
                                            : ''),
                                    style: Theme.of(
                                      context,
                                    ).textTheme.bodySmall,
                                    overflow: TextOverflow.ellipsis,
                                    maxLines: 1,
                                  )
                                : const SizedBox.shrink(),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),
                    if (summary.isNotEmpty)
                      Wrap(
                        spacing: 8,
                        runSpacing: 8,
                        children: [
                          MiniStatCard(
                            title: 'Registros',
                            value: '${summary['total_records'] ?? 0}',
                            icon: Icons.list_alt,
                            color: Colors.indigo,
                          ),
                          MiniStatCard(
                            title: 'Inicial',
                            value: ReportFormatters.formatCurrency(
                              summary['total_initial'] ?? 0,
                            ),
                            icon: Icons.start,
                            color: Colors.blueGrey,
                          ),
                          MiniStatCard(
                            title: 'Recaudado',
                            value: ReportFormatters.formatCurrency(
                              summary['total_collected'] ?? 0,
                            ),
                            icon: Icons.call_received,
                            color: Colors.green,
                          ),
                          MiniStatCard(
                            title: 'Prestado',
                            value: ReportFormatters.formatCurrency(summary['total_lent'] ?? 0),
                            icon: Icons.call_made,
                            color: Colors.orange,
                          ),
                          MiniStatCard(
                            title: 'Final',
                            value: ReportFormatters.formatCurrency(summary['total_final'] ?? 0),
                            icon: Icons.summarize,
                            color: Colors.indigo,
                          ),
                          MiniStatCard(
                            title: 'Dif. promedio',
                            value: ReportFormatters.formatCurrency(
                              summary['average_difference'] ?? 0,
                            ),
                            icon: Icons.calculate,
                            color: Colors.deepPurple,
                          ),
                        ],
                      ),
                    const SizedBox(height: 12),
                    if (typedBalances.isNotEmpty) ...[
                      buildBalancesList(typedBalances, context),
                      const SizedBox(height: 12),
                    ] else ...[
                      Card(
                        child: Padding(
                          padding: const EdgeInsets.all(16.0),
                          child: Row(
                            children: const [
                              Icon(Icons.inbox, color: Colors.grey),
                              SizedBox(width: 12),
                              Expanded(
                                child: Text(
                                  'No hay balances para los filtros seleccionados.',
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ],
                    SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: buildTableFromJson(
                        rows,
                        columnOrder: columnsOrder,
                      ),
                    ),
                  ],
                ),
              );
            } else {
              // No hay balances, pero mostrar resumen y acciones si existen
              final Map<String, dynamic> summary = (payload['summary'] is Map)
                  ? Map<String, dynamic>.from(payload['summary'] as Map)
                  : <String, dynamic>{};
              return SingleChildScrollView(
                padding: const EdgeInsets.all(8.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        ElevatedButton.icon(
                          onPressed: () async {
                            try {
                              final bytes = await ref
                                  .read(rp.reportsApiProvider)
                                  .generateReport(
                                    req.type,
                                    filters: req.filters,
                                    format: 'excel',
                                  );
                              if (bytes is List<int>) {
                                final dir =
                                    await getApplicationDocumentsDirectory();
                                final ts = DateTime.now()
                                    .toIso8601String()
                                    .replaceAll(':', '-');
                                final file = File(
                                  '${dir.path}/reporte_${req.type}_$ts.xlsx',
                                );
                                await file.writeAsBytes(bytes);
                                try {
                                  await OpenFilex.open(file.path);
                                } catch (_) {}
                                ScaffoldMessenger.of(context).showSnackBar(
                                  const SnackBar(
                                    content: Text('Excel descargado'),
                                  ),
                                );
                              }
                            } catch (e) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text('Error al descargar Excel: $e'),
                                ),
                              );
                            }
                          },
                          icon: const Icon(Icons.grid_on),
                          label: const Text('Excel'),
                        ),
                        const SizedBox(width: 8),
                        ElevatedButton.icon(
                          onPressed: () async {
                            try {
                              final bytes = await ref
                                  .read(rp.reportsApiProvider)
                                  .generateReport(
                                    req.type,
                                    filters: req.filters,
                                    format: 'pdf',
                                  );
                              if (bytes is List<int>) {
                                final dir =
                                    await getApplicationDocumentsDirectory();
                                final ts = DateTime.now()
                                    .toIso8601String()
                                    .replaceAll(':', '-');
                                final file = File(
                                  '${dir.path}/reporte_${req.type}_$ts.pdf',
                                );
                                await file.writeAsBytes(bytes);
                                try {
                                  await OpenFilex.open(file.path);
                                } catch (_) {}
                                ScaffoldMessenger.of(context).showSnackBar(
                                  const SnackBar(
                                    content: Text('PDF descargado'),
                                  ),
                                );
                              }
                            } catch (e) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text('Error al descargar PDF: $e'),
                                ),
                              );
                            }
                          },
                          icon: const Icon(Icons.picture_as_pdf),
                          label: const Text('PDF'),
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Align(
                            alignment: Alignment.centerRight,
                            child:
                                (payload['generated_by'] != null ||
                                    payload['generated_at'] != null)
                                ? Text(
                                    'Generado' +
                                        (payload['generated_by'] != null
                                            ? ' por ${payload['generated_by']}'
                                            : '') +
                                        (payload['generated_at'] != null
                                            ? ' ‚Ä¢ ${ReportFormatters.formatDate(payload['generated_at'])}'
                                            : ''),
                                    style: Theme.of(
                                      context,
                                    ).textTheme.bodySmall,
                                    overflow: TextOverflow.ellipsis,
                                    maxLines: 1,
                                  )
                                : const SizedBox.shrink(),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),
                    if (summary.isNotEmpty)
                      Wrap(
                        spacing: 8,
                        runSpacing: 8,
                        children: [
                          MiniStatCard(
                            title: 'Registros',
                            value: '${summary['total_records'] ?? 0}',
                            icon: Icons.list_alt,
                            color: Colors.indigo,
                          ),
                          MiniStatCard(
                            title: 'Inicial',
                            value: ReportFormatters.formatCurrency(
                              summary['total_initial'] ?? 0,
                            ),
                            icon: Icons.start,
                            color: Colors.blueGrey,
                          ),
                          MiniStatCard(
                            title: 'Recaudado',
                            value: ReportFormatters.formatCurrency(
                              summary['total_collected'] ?? 0,
                            ),
                            icon: Icons.call_received,
                            color: Colors.green,
                          ),
                          MiniStatCard(
                            title: 'Prestado',
                            value: ReportFormatters.formatCurrency(summary['total_lent'] ?? 0),
                            icon: Icons.call_made,
                            color: Colors.orange,
                          ),
                          MiniStatCard(
                            title: 'Final',
                            value: ReportFormatters.formatCurrency(summary['total_final'] ?? 0),
                            icon: Icons.summarize,
                            color: Colors.indigo,
                          ),
                          MiniStatCard(
                            title: 'Dif. promedio',
                            value: ReportFormatters.formatCurrency(
                              summary['average_difference'] ?? 0,
                            ),
                            icon: Icons.calculate,
                            color: Colors.deepPurple,
                          ),
                        ],
                      ),
                    const SizedBox(height: 12),
                    Card(
                      child: Padding(
                        padding: const EdgeInsets.all(16.0),
                        child: Row(
                          children: const [
                            Icon(Icons.inbox, color: Colors.grey),
                            SizedBox(width: 12),
                            Expanded(
                              child: Text(
                                'No hay balances para los filtros seleccionados.',
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ],
                ),
              );
            }
          } else if (payload is Map && payload.containsKey('credits')) {
            // Detectar si es reporte de MORA (overdue) verificando campos espec√≠ficos
            final credits = payload['credits'];
            final summary = (payload['summary'] is Map)
                ? Map<String, dynamic>.from(payload['summary'] as Map)
                : <String, dynamic>{};

            // Es reporte de mora si el summary tiene campos espec√≠ficos de overdue
            final bool isOverdueReport =
                summary.containsKey('total_overdue_credits') ||
                summary.containsKey('average_days_overdue') ||
                summary.containsKey('by_severity');

            if (isOverdueReport &&
                credits is List &&
                credits.isNotEmpty &&
                credits.first is Map) {
              // REPORTE DE MORA (OVERDUE)
              final List<Map<String, dynamic>>
              rows = credits.map<Map<String, dynamic>>((c) {
                final Map<String, dynamic> cr = Map<String, dynamic>.from(
                  c as Map,
                );

                String clientName = '';
                String clientCategory = '';
                try {
                  if (cr['client'] is Map) {
                    clientName = cr['client']['name']?.toString() ?? '';
                    clientCategory =
                        cr['client']['client_category']?.toString() ?? '';
                  }
                } catch (_) {}

                String cobradorName = '';
                try {
                  if (cr['deliveredBy'] is Map) {
                    cobradorName = cr['deliveredBy']['name']?.toString() ?? '';
                  } else if (cr['cobrador'] is Map) {
                    cobradorName = cr['cobrador']['name']?.toString() ?? '';
                  }
                } catch (_) {}

                final daysOverdue = cr['days_overdue']?.toString() ?? '0';
                final overdueAmount = ReportFormatters.formatCurrency(cr['overdue_amount']);
                final balance = ReportFormatters.formatCurrency(cr['balance']);
                final completionRate = cr['completion_rate']?.toString() ?? '0';

                // Determinar gravedad
                String severity = 'Ligera';
                Color severityColor = Colors.orange;
                final days = int.tryParse(daysOverdue) ?? 0;
                if (days > 30) {
                  severity = 'Severa';
                  severityColor = Colors.red;
                } else if (days > 7) {
                  severity = 'Moderada';
                  severityColor = Colors.deepOrange;
                }

                return {
                  'ID': cr['id']?.toString() ?? '',
                  'Cliente': clientName,
                  'Categor√≠a': clientCategory,
                  'Cobrador': cobradorName,
                  'D√≠as Mora': daysOverdue,
                  'Gravedad': severity,
                  'Monto Vencido': overdueAmount,
                  'Balance Total': balance,
                  'Avance': '$completionRate%',
                  '_days_raw': days,
                  '_severity_color': severityColor,
                };
              }).toList();

              final columnsOrder = [
                'ID',
                'Cliente',
                'Categor√≠a',
                'Cobrador',
                'D√≠as Mora',
                'Gravedad',
                'Monto Vencido',
                'Balance Total',
                'Avance',
              ];

              return SingleChildScrollView(
                padding: const EdgeInsets.all(8.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Acciones r√°pidas de descarga
                    Row(
                      children: [
                        ElevatedButton.icon(
                          onPressed: () async {
                            try {
                              final bytes = await ref
                                  .read(rp.reportsApiProvider)
                                  .generateReport(
                                    req.type,
                                    filters: req.filters,
                                    format: 'excel',
                                  );
                              if (bytes is List<int>) {
                                final dir =
                                    await getApplicationDocumentsDirectory();
                                final ts = DateTime.now()
                                    .toIso8601String()
                                    .replaceAll(':', '-');
                                final fileName = 'reporte_${req.type}_$ts.xlsx';
                                final file = File('${dir.path}/$fileName');
                                await file.writeAsBytes(bytes);
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text(
                                      'Reporte guardado: $fileName',
                                    ),
                                    action: SnackBarAction(
                                      label: 'Abrir',
                                      onPressed: () {
                                        OpenFilex.open(file.path);
                                      },
                                    ),
                                  ),
                                );
                                try {
                                  await OpenFilex.open(file.path);
                                } catch (_) {}
                              }
                            } catch (e) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text('Error al descargar Excel: $e'),
                                ),
                              );
                            }
                          },
                          icon: const Icon(Icons.grid_on),
                          label: const Text('Excel'),
                        ),
                        const SizedBox(width: 8),
                        ElevatedButton.icon(
                          onPressed: () async {
                            try {
                              final bytes = await ref
                                  .read(rp.reportsApiProvider)
                                  .generateReport(
                                    req.type,
                                    filters: req.filters,
                                    format: 'pdf',
                                  );
                              if (bytes is List<int>) {
                                final dir =
                                    await getApplicationDocumentsDirectory();
                                final ts = DateTime.now()
                                    .toIso8601String()
                                    .replaceAll(':', '-');
                                final fileName = 'reporte_${req.type}_$ts.pdf';
                                final file = File('${dir.path}/$fileName');
                                await file.writeAsBytes(bytes);
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text(
                                      'Reporte guardado: $fileName',
                                    ),
                                    action: SnackBarAction(
                                      label: 'Abrir',
                                      onPressed: () {
                                        OpenFilex.open(file.path);
                                      },
                                    ),
                                  ),
                                );
                                try {
                                  await OpenFilex.open(file.path);
                                } catch (_) {}
                              }
                            } catch (e) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text('Error al descargar PDF: $e'),
                                ),
                              );
                            }
                          },
                          icon: const Icon(Icons.picture_as_pdf),
                          label: const Text('PDF'),
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Align(
                            alignment: Alignment.centerRight,
                            child:
                                (payload['generated_by'] != null ||
                                    payload['generated_at'] != null)
                                ? Text(
                                    'Generado' +
                                        (payload['generated_by'] != null
                                            ? ' por ${payload['generated_by']}'
                                            : '') +
                                        (payload['generated_at'] != null
                                            ? ' ‚Ä¢ ${ReportFormatters.formatDate(payload['generated_at'])}'
                                            : ''),
                                    style: Theme.of(
                                      context,
                                    ).textTheme.bodySmall,
                                    overflow: TextOverflow.ellipsis,
                                    maxLines: 1,
                                  )
                                : const SizedBox.shrink(),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),

                    // Cards de m√©tricas principales
                    if (summary.isNotEmpty)
                      Wrap(
                        spacing: 8,
                        runSpacing: 8,
                        children: [
                          MiniStatCard(
                            title: 'Cr√©ditos en Mora',
                            value: '${summary['total_overdue_credits'] ?? 0}',
                            icon: Icons.warning_amber_rounded,
                            color: Colors.red,
                          ),
                          MiniStatCard(
                            title: 'Monto Vencido',
                            value: ReportFormatters.formatCurrency(
                              summary['total_overdue_amount'] ?? 0,
                            ),
                            icon: Icons.attach_money,
                            color: Colors.deepOrange,
                          ),
                          MiniStatCard(
                            title: 'Balance Total',
                            value: ReportFormatters.formatCurrency(
                              summary['total_balance_overdue'] ?? 0,
                            ),
                            icon: Icons.account_balance_wallet,
                            color: Colors.orange,
                          ),
                          MiniStatCard(
                            title: 'D√≠as Promedio',
                            value:
                                '${(summary['average_days_overdue'] ?? 0).toStringAsFixed(1)} d√≠as',
                            icon: Icons.calendar_today,
                            color: Colors.blueGrey,
                          ),
                          MiniStatCard(
                            title: 'Rango D√≠as',
                            value:
                                '${summary['min_days_overdue'] ?? 0} - ${summary['max_days_overdue'] ?? 0}',
                            icon: Icons.straighten,
                            color: Colors.indigo,
                          ),
                        ],
                      ),
                    const SizedBox(height: 12),

                    // Distribuci√≥n por gravedad
                    if (summary['by_severity'] is Map) ...[
                      Card(
                        child: Padding(
                          padding: const EdgeInsets.all(16.0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: const [
                                  Icon(Icons.pie_chart, color: Colors.indigo),
                                  SizedBox(width: 8),
                                  Text(
                                    'Distribuci√≥n por Gravedad',
                                    style: TextStyle(
                                      fontSize: 16,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 12),
                              buildSeverityDistribution(
                                summary['by_severity'] as Map,
                                context,
                              ),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 12),
                    ],

                    // Top 10 deudores
                    if (summary['top_debtors'] is List &&
                        (summary['top_debtors'] as List).isNotEmpty) ...[
                      Card(
                        child: Padding(
                          padding: const EdgeInsets.all(16.0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: const [
                                  Icon(Icons.emoji_events, color: Colors.amber),
                                  SizedBox(width: 8),
                                  Text(
                                    'Top 10 Deudores',
                                    style: TextStyle(
                                      fontSize: 16,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 12),
                              buildTopDebtorsList(
                                summary['top_debtors'] as List,
                                context,
                              ),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 12),
                    ],

                    // An√°lisis por cobrador
                    if (summary['by_cobrador'] is Map &&
                        (summary['by_cobrador'] as Map).isNotEmpty) ...[
                      Card(
                        child: Padding(
                          padding: const EdgeInsets.all(16.0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: const [
                                  Icon(Icons.person, color: Colors.blue),
                                  SizedBox(width: 8),
                                  Text(
                                    'An√°lisis por Cobrador',
                                    style: TextStyle(
                                      fontSize: 16,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 12),
                              buildCobradorAnalysis(
                                summary['by_cobrador'] as Map,
                                context,
                              ),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 12),
                    ],

                    // An√°lisis por categor√≠a
                    if (summary['by_client_category'] is Map &&
                        (summary['by_client_category'] as Map).isNotEmpty) ...[
                      Card(
                        child: Padding(
                          padding: const EdgeInsets.all(16.0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: const [
                                  Icon(Icons.category, color: Colors.purple),
                                  SizedBox(width: 8),
                                  Text(
                                    'An√°lisis por Categor√≠a de Cliente',
                                    style: TextStyle(
                                      fontSize: 16,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 12),
                              buildCategoryAnalysis(
                                summary['by_client_category'] as Map,
                                context,
                              ),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 12),
                    ],

                    // Tabla de cr√©ditos en mora
                    SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: buildTableFromJson(
                        rows,
                        columnOrder: columnsOrder,
                      ),
                    ),
                  ],
                ),
              );
            }

            // ========== REPORTE DE RENDIMIENTO (PERFORMANCE) ==========
          } else if (payload is Map && payload.containsKey('performance')) {
            final performance = payload['performance'];
            final summary = (payload['summary'] is Map)
                ? Map<String, dynamic>.from(payload['summary'] as Map)
                : <String, dynamic>{};

            if (performance is List &&
                performance.isNotEmpty &&
                performance.first is Map) {
              return SingleChildScrollView(
                padding: const EdgeInsets.all(8.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Botones de descarga
                    buildDownloadButtons(context, ref, req, payload),
                    const SizedBox(height: 12),

                    // M√©tricas resumen
                    if (summary.isNotEmpty) ...[
                      Wrap(
                        spacing: 8,
                        runSpacing: 8,
                        children: [
                          MiniStatCard(
                            title: 'Cobradores',
                            value: '${summary['total_cobradores'] ?? 0}',
                            icon: Icons.people,
                            color: Colors.indigo,
                          ),
                          if (summary['totals'] is Map) ...[
                            MiniStatCard(
                              title: 'Cr√©ditos Entregados',
                              value:
                                  '${summary['totals']['credits_delivered'] ?? 0}',
                              icon: Icons.assignment_turned_in,
                              color: Colors.blue,
                            ),
                            MiniStatCard(
                              title: 'Monto Prestado',
                              value: ReportFormatters.formatCurrency(
                                summary['totals']['amount_lent'] ?? 0,
                              ),
                              icon: Icons.trending_up,
                              color: Colors.green,
                            ),
                            MiniStatCard(
                              title: 'Monto Cobrado',
                              value: ReportFormatters.formatCurrency(
                                summary['totals']['amount_collected'] ?? 0,
                              ),
                              icon: Icons.payments,
                              color: Colors.teal,
                            ),
                          ],
                          if (summary['averages'] is Map) ...[
                            MiniStatCard(
                              title: 'Tasa Cobranza Prom.',
                              value:
                                  '${summary['averages']['collection_rate']?.toStringAsFixed(1) ?? 0}%',
                              icon: Icons.percent,
                              color: Colors.orange,
                            ),
                            MiniStatCard(
                              title: 'Calidad Cartera Prom.',
                              value:
                                  '${summary['averages']['portfolio_quality']?.toStringAsFixed(1) ?? 0}%',
                              icon: Icons.star,
                              color: Colors.amber,
                            ),
                          ],
                        ],
                      ),
                      const SizedBox(height: 12),
                    ],

                    // Top Performers
                    if (summary['top_performers'] is List &&
                        (summary['top_performers'] as List).isNotEmpty) ...[
                      Card(
                        child: Padding(
                          padding: const EdgeInsets.all(16.0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: const [
                                  Icon(Icons.emoji_events, color: Colors.amber),
                                  SizedBox(width: 8),
                                  Text(
                                    'Mejores Cobradores',
                                    style: TextStyle(
                                      fontSize: 16,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 12),
                              buildTopPerformersList(
                                summary['top_performers'] as List,
                                context,
                              ),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 12),
                    ],

                    // Lista de performance por cobrador
                    buildPerformanceList(performance as List, context),
                  ],
                ),
              );
            }

            // ========== REPORTE DE ACTIVIDAD DIARIA (DAILY ACTIVITY) ==========
          } else if (payload is Map && payload.containsKey('activities')) {
            final activities = payload['activities'];
            final summary = (payload['summary'] is Map)
                ? Map<String, dynamic>.from(payload['summary'] as Map)
                : <String, dynamic>{};

            if (activities is List &&
                activities.isNotEmpty &&
                activities.first is Map) {
              return SingleChildScrollView(
                padding: const EdgeInsets.all(8.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Botones de descarga
                    buildDownloadButtons(context, ref, req, payload),
                    const SizedBox(height: 12),

                    // Resumen del d√≠a
                    if (summary.isNotEmpty) ...[
                      Card(
                        color: Colors.indigo.withOpacity(0.05),
                        child: Padding(
                          padding: const EdgeInsets.all(16.0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: [
                                  const Icon(
                                    Icons.today,
                                    color: Colors.indigo,
                                    size: 28,
                                  ),
                                  const SizedBox(width: 12),
                                  Text(
                                    'Actividad del ${summary['date'] ?? ''} (${summary['day_name'] ?? ''})',
                                    style: const TextStyle(
                                      fontSize: 18,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 16),
                              if (summary['totals'] is Map)
                                Wrap(
                                  spacing: 8,
                                  runSpacing: 8,
                                  children: [
                                    MiniStatCard(
                                      title: 'Cr√©ditos Entregados',
                                      value:
                                          '${summary['totals']['credits_delivered'] ?? 0}',
                                      icon: Icons.local_shipping,
                                      color: Colors.blue,
                                    ),
                                    MiniStatCard(
                                      title: 'Monto Prestado',
                                      value: ReportFormatters.formatCurrency(
                                        summary['totals']['amount_lent'] ?? 0,
                                      ),
                                      icon: Icons.trending_up,
                                      color: Colors.green,
                                    ),
                                    MiniStatCard(
                                      title: 'Pagos Cobrados',
                                      value:
                                          '${summary['totals']['payments_collected'] ?? 0}',
                                      icon: Icons.payment,
                                      color: Colors.teal,
                                    ),
                                    MiniStatCard(
                                      title: 'Monto Cobrado',
                                      value: ReportFormatters.formatCurrency(
                                        summary['totals']['amount_collected'] ??
                                            0,
                                      ),
                                      icon: Icons.attach_money,
                                      color: Colors.green[700]!,
                                    ),
                                    MiniStatCard(
                                      title: 'Eficiencia General',
                                      value:
                                          '${summary['overall_efficiency']?.toStringAsFixed(1) ?? 0}%',
                                      icon: Icons.speed,
                                      color: Colors.orange,
                                    ),
                                  ],
                                ),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 12),
                    ],

                    // Actividades por cobrador
                    buildDailyActivitiesList(activities as List, context),
                  ],
                ),
              );
            }

            // ========== REPORTE DE PROYECCI√ìN DE FLUJO (CASH FLOW FORECAST) ==========
          } else if (payload is Map && payload.containsKey('projections')) {
            final projections = payload['projections'];
            final summary = (payload['summary'] is Map)
                ? Map<String, dynamic>.from(payload['summary'] as Map)
                : <String, dynamic>{};

            if (projections is List &&
                projections.isNotEmpty &&
                projections.first is Map) {
              return SingleChildScrollView(
                padding: const EdgeInsets.all(8.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Botones de descarga
                    buildDownloadButtons(context, ref, req, payload),
                    const SizedBox(height: 12),

                    // Resumen de proyecci√≥n
                    if (summary.isNotEmpty) ...[
                      Wrap(
                        spacing: 8,
                        runSpacing: 8,
                        children: [
                          MiniStatCard(
                            title: 'Cr√©ditos Activos',
                            value: '${summary['total_active_credits'] ?? 0}',
                            icon: Icons.credit_card,
                            color: Colors.indigo,
                          ),
                          MiniStatCard(
                            title: 'Pagos Proyectados',
                            value:
                                '${summary['total_projected_payments'] ?? 0}',
                            icon: Icons.event,
                            color: Colors.blue,
                          ),
                          MiniStatCard(
                            title: 'Monto Proyectado',
                            value: ReportFormatters.formatCurrency(
                              summary['total_projected_amount'] ?? 0,
                            ),
                            icon: Icons.account_balance_wallet,
                            color: Colors.green,
                          ),
                          MiniStatCard(
                            title: 'Monto Vencido',
                            value: ReportFormatters.formatCurrency(
                              summary['overdue_amount'] ?? 0,
                            ),
                            icon: Icons.warning,
                            color: Colors.red,
                          ),
                          MiniStatCard(
                            title: 'Monto Pendiente',
                            value: ReportFormatters.formatCurrency(
                              summary['pending_amount'] ?? 0,
                            ),
                            icon: Icons.schedule,
                            color: Colors.orange,
                          ),
                        ],
                      ),
                      const SizedBox(height: 12),
                    ],

                    // Distribuci√≥n por frecuencia
                    if (summary['by_frequency'] is Map) ...[
                      Card(
                        child: Padding(
                          padding: const EdgeInsets.all(16.0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: const [
                                  Icon(Icons.sync, color: Colors.purple),
                                  SizedBox(width: 8),
                                  Text(
                                    'Distribuci√≥n por Frecuencia',
                                    style: TextStyle(
                                      fontSize: 16,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 12),
                              buildFrequencyDistribution(
                                summary['by_frequency'] as Map,
                                context,
                              ),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 12),
                    ],

                    // Proyecciones por per√≠odo
                    buildProjectionsList(projections as List, context),
                  ],
                ),
              );
            }

            // ========== REPORTE DE CARTERA (PORTFOLIO) ==========
          } else if (payload is Map &&
              payload.containsKey('portfolio_by_cobrador')) {
            final summary = (payload['summary'] is Map)
                ? Map<String, dynamic>.from(payload['summary'] as Map)
                : <String, dynamic>{};

            return SingleChildScrollView(
              padding: const EdgeInsets.all(8.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Botones de descarga
                  buildDownloadButtons(context, ref, req, payload),
                  const SizedBox(height: 12),

                  // Resumen general
                  if (summary.isNotEmpty) ...[
                    Wrap(
                      spacing: 8,
                      runSpacing: 8,
                      children: [
                        MiniStatCard(
                          title: 'Cr√©ditos Totales',
                          value: '${summary['total_credits'] ?? 0}',
                          icon: Icons.assignment,
                          color: Colors.indigo,
                        ),
                        MiniStatCard(
                          title: 'Cr√©ditos Activos',
                          value: '${summary['active_credits'] ?? 0}',
                          icon: Icons.trending_up,
                          color: Colors.blue,
                        ),
                        MiniStatCard(
                          title: 'Total Prestado',
                          value: ReportFormatters.formatCurrency(summary['total_lent'] ?? 0),
                          icon: Icons.monetization_on,
                          color: Colors.green,
                        ),
                        MiniStatCard(
                          title: 'Total Cobrado',
                          value: ReportFormatters.formatCurrency(
                            summary['total_collected'] ?? 0,
                          ),
                          icon: Icons.account_balance,
                          color: Colors.teal,
                        ),
                        MiniStatCard(
                          title: 'Balance Activo',
                          value: ReportFormatters.formatCurrency(
                            summary['active_balance'] ?? 0,
                          ),
                          icon: Icons.account_balance_wallet,
                          color: Colors.orange,
                        ),
                        MiniStatCard(
                          title: 'Calidad Cartera',
                          value:
                              '${summary['portfolio_quality']?.toStringAsFixed(1) ?? 0}%',
                          icon: Icons.star,
                          color: Colors.amber,
                        ),
                        MiniStatCard(
                          title: 'Tasa Recuperaci√≥n',
                          value:
                              '${summary['collection_rate']?.toStringAsFixed(1) ?? 0}%',
                          icon: Icons.trending_up,
                          color: Colors.green[700]!,
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),
                  ],

                  // Top clientes por balance
                  if (payload['top_clients_by_balance'] is List &&
                      (payload['top_clients_by_balance'] as List)
                          .isNotEmpty) ...[
                    Card(
                      child: Padding(
                        padding: const EdgeInsets.all(16.0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Row(
                              children: const [
                                Icon(Icons.person_pin, color: Colors.blue),
                                SizedBox(width: 8),
                                Text(
                                  'Top Clientes por Balance',
                                  style: TextStyle(
                                    fontSize: 16,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ],
                            ),
                            const SizedBox(height: 12),
                            buildTopClientsList(
                              payload['top_clients_by_balance'] as List,
                              context,
                            ),
                          ],
                        ),
                      ),
                    ),
                    const SizedBox(height: 12),
                  ],

                  // Cartera por cobrador
                  if (payload['portfolio_by_cobrador'] is Map) ...[
                    Card(
                      child: Padding(
                        padding: const EdgeInsets.all(16.0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Row(
                              children: const [
                                Icon(Icons.people, color: Colors.indigo),
                                SizedBox(width: 8),
                                Text(
                                  'Cartera por Cobrador',
                                  style: TextStyle(
                                    fontSize: 16,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ],
                            ),
                            const SizedBox(height: 12),
                            buildPortfolioByCobrador(
                              payload['portfolio_by_cobrador'] as Map,
                              context,
                            ),
                          ],
                        ),
                      ),
                    ),
                    const SizedBox(height: 12),
                  ],

                  // Distribuci√≥n por categor√≠a
                  if (payload['portfolio_by_category'] is Map) ...[
                    Card(
                      child: Padding(
                        padding: const EdgeInsets.all(16.0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Row(
                              children: const [
                                Icon(Icons.category, color: Colors.purple),
                                SizedBox(width: 8),
                                Text(
                                  'Cartera por Categor√≠a',
                                  style: TextStyle(
                                    fontSize: 16,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ],
                            ),
                            const SizedBox(height: 12),
                            buildPortfolioByCategory(
                              payload['portfolio_by_category'] as Map,
                              context,
                            ),
                          ],
                        ),
                      ),
                    ),
                  ],
                ],
              ),
            );

            // ========== REPORTE DE LISTA DE ESPERA (WAITING LIST) ==========
          } else if (payload is Map && payload.containsKey('credits')) {
            final credits = payload['credits'];
            final summary = (payload['summary'] is Map)
                ? Map<String, dynamic>.from(payload['summary'] as Map)
                : <String, dynamic>{};

            // Verificar si es reporte de waiting list
            final bool isWaitingListReport = summary.containsKey(
              'total_in_waiting_list',
            );

            if (isWaitingListReport &&
                credits is List &&
                credits.isNotEmpty &&
                credits.first is Map) {
              final List<Map<String, dynamic>> rows = credits
                  .map<Map<String, dynamic>>((c) {
                    final Map<String, dynamic> cr = Map<String, dynamic>.from(
                      c as Map,
                    );
                    String clientName = '';
                    String creatorName = '';

                    if (cr['client'] is Map)
                      clientName = cr['client']['name']?.toString() ?? '';
                    if (cr['createdBy'] is Map)
                      creatorName = cr['createdBy']['name']?.toString() ?? '';

                    return {
                      'ID': cr['id']?.toString() ?? '',
                      'Cliente': clientName,
                      'Creado por': creatorName,
                      'Monto': ReportFormatters.formatCurrency(cr['amount']),
                      'Estado':
                          cr['status_label']?.toString() ??
                          cr['status']?.toString() ??
                          '',
                      'D√≠as Esperando': cr['days_waiting']?.toString() ?? '0',
                      'Entrega Programada': ReportFormatters.formatDate(
                        cr['scheduled_delivery_date'],
                      ),
                      'Vencido': (cr['is_overdue_delivery'] == true)
                          ? 'S√≠'
                          : 'No',
                    };
                  })
                  .toList();

              final columnsOrder = [
                'ID',
                'Cliente',
                'Creado por',
                'Monto',
                'Estado',
                'D√≠as Esperando',
                'Entrega Programada',
                'Vencido',
              ];

              return SingleChildScrollView(
                padding: const EdgeInsets.all(8.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Botones de descarga
                    buildDownloadButtons(context, ref, req, payload),
                    const SizedBox(height: 12),

                    // Resumen
                    if (summary.isNotEmpty)
                      Wrap(
                        spacing: 8,
                        runSpacing: 8,
                        children: [
                          MiniStatCard(
                            title: 'Total en Espera',
                            value: '${summary['total_in_waiting_list'] ?? 0}',
                            icon: Icons.hourglass_empty,
                            color: Colors.orange,
                          ),
                          MiniStatCard(
                            title: 'Pendiente Aprobaci√≥n',
                            value: '${summary['pending_approval'] ?? 0}',
                            icon: Icons.pending_actions,
                            color: Colors.amber,
                          ),
                          MiniStatCard(
                            title: 'Esperando Entrega',
                            value: '${summary['waiting_delivery'] ?? 0}',
                            icon: Icons.local_shipping,
                            color: Colors.blue,
                          ),
                          MiniStatCard(
                            title: 'Vencidos Entrega',
                            value: '${summary['overdue_for_delivery'] ?? 0}',
                            icon: Icons.warning,
                            color: Colors.red,
                          ),
                          MiniStatCard(
                            title: 'Monto Total',
                            value: ReportFormatters.formatCurrency(
                              summary['total_amount_pending'] ?? 0,
                            ),
                            icon: Icons.attach_money,
                            color: Colors.green,
                          ),
                          MiniStatCard(
                            title: 'D√≠as Prom. Espera',
                            value:
                                '${summary['avg_days_waiting']?.toStringAsFixed(1) ?? 0}',
                            icon: Icons.schedule,
                            color: Colors.indigo,
                          ),
                        ],
                      ),
                    const SizedBox(height: 12),

                    // Tabla
                    SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: buildTableFromJson(
                        rows,
                        columnOrder: columnsOrder,
                      ),
                    ),
                  ],
                ),
              );
            }

            // ========== REPORTE DE COMISIONES (COMMISSIONS) ==========
          } else if (payload is Map && payload.containsKey('commissions')) {
            final commissions = payload['commissions'];
            final summary = (payload['summary'] is Map)
                ? Map<String, dynamic>.from(payload['summary'] as Map)
                : <String, dynamic>{};

            if (commissions is List &&
                commissions.isNotEmpty &&
                commissions.first is Map) {
              return SingleChildScrollView(
                padding: const EdgeInsets.all(8.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Botones de descarga
                    buildDownloadButtons(context, ref, req, payload),
                    const SizedBox(height: 12),

                    // Resumen
                    if (summary.isNotEmpty) ...[
                      Card(
                        color: Colors.green.withOpacity(0.05),
                        child: Padding(
                          padding: const EdgeInsets.all(16.0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: [
                                  const Icon(
                                    Icons.monetization_on,
                                    color: Colors.green,
                                    size: 28,
                                  ),
                                  const SizedBox(width: 12),
                                  if (summary['period'] is Map)
                                    Text(
                                      'Comisiones ${summary['period']['start']} - ${summary['period']['end']}',
                                      style: const TextStyle(
                                        fontSize: 18,
                                        fontWeight: FontWeight.bold,
                                      ),
                                    ),
                                ],
                              ),
                              const SizedBox(height: 16),
                              Wrap(
                                spacing: 8,
                                runSpacing: 8,
                                children: [
                                  MiniStatCard(
                                    title: 'Tasa Comisi√≥n',
                                    value:
                                        '${summary['commission_rate']?.toStringAsFixed(1) ?? 0}%',
                                    icon: Icons.percent,
                                    color: Colors.indigo,
                                  ),
                                  MiniStatCard(
                                    title: 'Cobradores',
                                    value:
                                        '${summary['total_cobradores'] ?? 0}',
                                    icon: Icons.people,
                                    color: Colors.blue,
                                  ),
                                  if (summary['totals'] is Map) ...[
                                    MiniStatCard(
                                      title: 'Total Cobrado',
                                      value: ReportFormatters.formatCurrency(
                                        summary['totals']['collected'] ?? 0,
                                      ),
                                      icon: Icons.attach_money,
                                      color: Colors.green,
                                    ),
                                    MiniStatCard(
                                      title: 'Total Comisiones',
                                      value: ReportFormatters.formatCurrency(
                                        summary['totals']['commissions'] ?? 0,
                                      ),
                                      icon: Icons.account_balance_wallet,
                                      color: Colors.teal,
                                    ),
                                    MiniStatCard(
                                      title: 'Total Bonos',
                                      value: ReportFormatters.formatCurrency(
                                        summary['totals']['bonuses'] ?? 0,
                                      ),
                                      icon: Icons.card_giftcard,
                                      color: Colors.amber,
                                    ),
                                  ],
                                ],
                              ),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 12),
                    ],

                    // Top earners
                    if (summary['top_earners'] is List &&
                        (summary['top_earners'] as List).isNotEmpty) ...[
                      Card(
                        child: Padding(
                          padding: const EdgeInsets.all(16.0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: const [
                                  Icon(Icons.emoji_events, color: Colors.amber),
                                  SizedBox(width: 8),
                                  Text(
                                    'Mayores Comisiones',
                                    style: TextStyle(
                                      fontSize: 16,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 12),
                              buildTopEarnersList(
                                summary['top_earners'] as List,
                                context,
                              ),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 12),
                    ],

                    // Lista de comisiones
                    buildCommissionsList(commissions as List, context),
                  ],
                ),
              );
            }

            // ========== REPORTE DE USUARIOS (USERS) ==========
          } else if (payload is Map && payload.containsKey('users')) {
            final users = payload['users'];
            final summary = (payload['summary'] is Map)
                ? Map<String, dynamic>.from(payload['summary'] as Map)
                : <String, dynamic>{};

            if (users is List && users.isNotEmpty && users.first is Map) {
              final List<Map<String, dynamic>> rows = users
                  .map<Map<String, dynamic>>((u) {
                    final Map<String, dynamic> user = Map<String, dynamic>.from(
                      u as Map,
                    );
                    final roles = (user['roles'] is List)
                        ? (user['roles'] as List).join(', ')
                        : '';

                    return {
                      'ID': user['id']?.toString() ?? '',
                      'Nombre':
                          user['nombre']?.toString() ??
                          user['name']?.toString() ??
                          '',
                      'CI': user['ci']?.toString() ?? '',
                      'Email': user['email']?.toString() ?? '',
                      'Tel√©fono':
                          user['telefono']?.toString() ??
                          user['phone']?.toString() ??
                          '',
                      'Roles': roles,
                      'Categor√≠a': user['client_category']?.toString() ?? '-',
                    };
                  })
                  .toList();

              final columnsOrder = [
                'ID',
                'Nombre',
                'CI',
                'Email',
                'Tel√©fono',
                'Roles',
                'Categor√≠a',
              ];

              return SingleChildScrollView(
                padding: const EdgeInsets.all(8.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Botones de descarga
                    buildDownloadButtons(context, ref, req, payload),
                    const SizedBox(height: 12),

                    // Resumen
                    if (summary.isNotEmpty)
                      Wrap(
                        spacing: 8,
                        runSpacing: 8,
                        children: [
                          MiniStatCard(
                            title: 'Total Usuarios',
                            value: '${summary['total_users'] ?? 0}',
                            icon: Icons.people,
                            color: Colors.indigo,
                          ),
                          if (summary['by_role'] is Map) ...[
                            if (summary['by_role']['admin'] != null)
                              MiniStatCard(
                                title: 'Admins',
                                value: '${summary['by_role']['admin'] ?? 0}',
                                icon: Icons.admin_panel_settings,
                                color: Colors.red,
                              ),
                            if (summary['by_role']['manager'] != null)
                              MiniStatCard(
                                title: 'Managers',
                                value: '${summary['by_role']['manager'] ?? 0}',
                                icon: Icons.business,
                                color: Colors.blue,
                              ),
                            if (summary['by_role']['cobrador'] != null)
                              MiniStatCard(
                                title: 'Cobradores',
                                value: '${summary['by_role']['cobrador'] ?? 0}',
                                icon: Icons.person,
                                color: Colors.green,
                              ),
                            if (summary['by_role']['client'] != null)
                              MiniStatCard(
                                title: 'Clientes',
                                value: '${summary['by_role']['client'] ?? 0}',
                                icon: Icons.person_outline,
                                color: Colors.orange,
                              ),
                          ],
                        ],
                      ),
                    const SizedBox(height: 12),

                    // Distribuci√≥n por categor√≠a
                    if (summary['by_category'] is Map &&
                        (summary['by_category'] as Map).isNotEmpty) ...[
                      Card(
                        child: Padding(
                          padding: const EdgeInsets.all(16.0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: const [
                                  Icon(Icons.category, color: Colors.purple),
                                  SizedBox(width: 8),
                                  Text(
                                    'Clientes por Categor√≠a',
                                    style: TextStyle(
                                      fontSize: 16,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 12),
                              buildUsersCategoryDistribution(
                                summary['by_category'] as Map,
                                context,
                              ),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 12),
                    ],

                    // Tabla
                    SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: buildTableFromJson(
                        rows,
                        columnOrder: columnsOrder,
                      ),
                    ),
                  ],
                ),
              );
            }
          } else if (payload is List &&
              payload.isNotEmpty &&
              payload.first is Map) {
            // Si es una lista gen√©rica de maps, intentar formatear similarmente (flatten de campos simples)
            final genericRows = List<Map<String, dynamic>>.from(payload);
            // Convertir valores simples a strings
            final formatted = genericRows
                .map((g) => g.map((k, v) => MapEntry(k.toString(), v)))
                .toList();

            return SingleChildScrollView(
              padding: const EdgeInsets.all(8.0),
              child: SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                child: buildTableFromJson(formatted),
              ),
            );
          } else if (payload is Map) {
            return SingleChildScrollView(
              padding: const EdgeInsets.all(8.0),
              scrollDirection: Axis.horizontal,
              child: buildTableFromMap(payload as Map<String, dynamic>),
            );
          }

          // Fallback: mostrar JSON crudo
          return SingleChildScrollView(
            padding: const EdgeInsets.all(8.0),
            child: Text(value.toString()),
          );
        }

        final filters = req.filters ?? {};

        // Para binarios ofrecer descarga
        return Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Text('Reporte binario listo.'),
              const SizedBox(height: 12),
              ElevatedButton.icon(
                icon: const Icon(Icons.download),
                label: const Text('Descargar'),
                onPressed: () async {
                  try {
                    if (value is List<int>) {
                      final dir = await getApplicationDocumentsDirectory();

                      // Construir nombre con timestamp y filtros resumidos
                      final ts = DateTime.now().toIso8601String().replaceAll(
                        ':',
                        '-',
                      );
                      String filterTag = '';
                      if (filters.isNotEmpty) {
                        final parts = filters.entries
                            .where(
                              (e) =>
                                  e.value != null &&
                                  e.value.toString().isNotEmpty,
                            )
                            .map((e) => '${e.key}=${e.value}')
                            .toList();
                        if (parts.isNotEmpty) {
                          filterTag =
                              '_' + parts.join('_').replaceAll(' ', '-');
                        }
                      }

                      final safeReportKey = req.type.replaceAll(
                        RegExp(r'[^a-zA-Z0-9_]'),
                        '_',
                      );
                      final fileName =
                          'reporte_${safeReportKey}${filterTag}_$ts.${req.format}';
                      final filePath = '${dir.path}/$fileName';
                      final file = File(filePath);
                      await file.writeAsBytes(value);

                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text('Reporte guardado: $fileName'),
                          action: SnackBarAction(
                            label: 'Abrir',
                            onPressed: () {
                              OpenFilex.open(file.path);
                            },
                          ),
                        ),
                      );

                      // Abrir autom√°ticamente (intento silencioso)
                      try {
                        await OpenFilex.open(file.path);
                      } catch (_) {}

                      // Ofrecer compartir
                      showModalBottomSheet(
                        context: context,
                        builder: (ctx) => SafeArea(
                          child: Wrap(
                            children: [
                              ListTile(
                                leading: const Icon(Icons.share),
                                title: const Text('Compartir'),
                                onTap: () async {
                                  Navigator.of(ctx).pop();
                                  await Share.shareXFiles([
                                    XFile(file.path),
                                  ], text: 'Reporte $fileName');
                                },
                              ),
                              ListTile(
                                leading: const Icon(Icons.open_in_new),
                                title: const Text('Abrir'),
                                onTap: () {
                                  Navigator.of(ctx).pop();
                                  OpenFilex.open(file.path);
                                },
                              ),
                              ListTile(
                                leading: const Icon(Icons.close),
                                title: const Text('Cerrar'),
                                onTap: () => Navigator.of(ctx).pop(),
                              ),
                            ],
                          ),
                        ),
                      );
                    } else {
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('Respuesta inesperada: no son bytes'),
                        ),
                      );
                    }
                  } catch (e) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Error guardando archivo: $e')),
                    );
                  }
                },
              ),
            ],
          ),
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (e, st) => Center(child: Text('Error generando reporte: $e')),
    );
  }
}

// ==========================
// Vista especial: Pagos de Hoy
// ==========================
String _formatTime(dynamic val) {
  if (val == null) return '';
  try {
    DateTime? dt;
    if (val is DateTime) {
      dt = val;
    } else {
      dt = DateTime.tryParse(val.toString());
    }
    if (dt == null) return '';
    final hh = dt.hour.toString().padLeft(2, '0');
    final mm = dt.minute.toString().padLeft(2, '0');
    return '$hh:$mm';
  } catch (_) {
    return '';
  }
}

IconData _iconForPaymentMethod(String? method) {
  switch ((method ?? '').toLowerCase()) {
    case 'cash':
      return Icons.payments;
    case 'transfer':
      return Icons.wallet;
    case 'card':
      return Icons.credit_card;
    case 'mobile_payment':
      return Icons.phone_iphone;
    default:
      return Icons.attach_money;
  }
}

Color _colorForPaymentMethod(String? method) {
  switch ((method ?? '').toLowerCase()) {
    case 'cash':
      return Colors.green;
    case 'transfer':
      return Colors.blue;
    case 'card':
      return Colors.purple;
    case 'mobile_payment':
      return Colors.teal;
    default:
      return Colors.grey;
  }
}

Color _colorForStatus(String? status) {
  switch ((status ?? '').toLowerCase()) {
    case 'completed':
      return Colors.green;
    case 'pending':
      return Colors.amber;
    case 'failed':
      return Colors.red;
    case 'cancelled':
      return Colors.grey;
    case 'partial':
      return Colors.blueGrey;
    default:
      return Colors.blueGrey;
  }
}

Widget buildTodayPaymentsList(
  List<Map<String, dynamic>> payments,
  BuildContext context,
) {
  String _extractClientName(Map<String, dynamic> pm) {
    try {
      if (pm['client'] is Map && pm['client']['name'] != null) {
        return pm['client']['name'].toString();
      }
      if (pm['credit'] is Map) {
        final credit = pm['credit'] as Map;
        if (credit['client'] is Map && credit['client']['name'] != null) {
          return credit['client']['name'].toString();
        }
        if (credit['client_name'] != null) {
          return credit['client_name'].toString();
        }
      }
      if (pm['client_name'] != null) return pm['client_name'].toString();
    } catch (_) {}
    return 'Cliente';
  }

  String _extractCobradorName(Map<String, dynamic> pm) {
    try {
      if (pm['cobrador'] is Map && pm['cobrador']['name'] != null) {
        return pm['cobrador']['name'].toString();
      }
      if (pm['cobrador_name'] != null) return pm['cobrador_name'].toString();
    } catch (_) {}
    return '';
  }

  double _sumAmounts() {
    double total = 0.0;
    for (final pm in payments) {
      final raw = pm['amount'];
      final d = double.tryParse(raw?.toString() ?? '0') ?? 0.0;
      total += d;
    }
    return total;
  }

  final total = _sumAmounts();
  final totalStr = ReportFormatters.formatCurrency(total);

  return Column(
    crossAxisAlignment: CrossAxisAlignment.start,
    children: [
      Row(
        children: [
          const Icon(Icons.today, color: Colors.indigo),
          const SizedBox(width: 8),
          Text(
            'Pagos de hoy',
            style: Theme.of(
              context,
            ).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
          ),
          const SizedBox(width: 8),
          Chip(
            label: Text('${payments.length}'),
            backgroundColor: Colors.indigo.withOpacity(0.08),
            side: BorderSide(color: Colors.indigo.withOpacity(0.2)),
          ),
          const Spacer(),
          Text(
            totalStr,
            style: Theme.of(context).textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
              color: Colors.green,
            ),
          ),
        ],
      ),
      const SizedBox(height: 8),
      ListView.separated(
        shrinkWrap: true,
        physics: const NeverScrollableScrollPhysics(),
        itemCount: payments.length,
        separatorBuilder: (_, __) => const SizedBox(height: 8),
        itemBuilder: (ctx, i) {
          final pm = payments[i];
          final clientName = _extractClientName(pm);
          final cobradorName = _extractCobradorName(pm);
          final method = pm['payment_method']?.toString();
          final status = pm['status']?.toString();
          final cuota = pm['installment_number']?.toString();
          final amountStr = ReportFormatters.formatCurrency(pm['amount']);
          final timeStr = _formatTime(pm['payment_date']);
          final colorMethod = _colorForPaymentMethod(method);
          final iconMethod = _iconForPaymentMethod(method);
          final statusColor = _colorForStatus(status);

          return Card(
            elevation: 1,
            child: ListTile(
              leading: CircleAvatar(
                backgroundColor: colorMethod.withOpacity(0.12),
                foregroundColor: colorMethod,
                child: Icon(iconMethod),
              ),
              title: Text(
                clientName,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
                style: const TextStyle(fontWeight: FontWeight.w600),
              ),
              subtitle: Padding(
                padding: const EdgeInsets.only(top: 6.0),
                child: Wrap(
                  spacing: 6,
                  runSpacing: 4,
                  crossAxisAlignment: WrapCrossAlignment.center,
                  children: [
                    Chip(
                      label: Text((method ?? '').toUpperCase()),
                      backgroundColor: colorMethod.withOpacity(0.08),
                      side: BorderSide(color: colorMethod.withOpacity(0.2)),
                      visualDensity: VisualDensity.compact,
                      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                    ),
                    if (cuota != null && cuota.isNotEmpty)
                      Chip(
                        label: Text('Cuota $cuota'),
                        backgroundColor: Theme.of(
                          context,
                        ).primaryColor.withOpacity(0.08),
                        side: BorderSide(
                          color: Theme.of(
                            context,
                          ).primaryColor.withOpacity(0.2),
                        ),
                        visualDensity: VisualDensity.compact,
                        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                      ),
                    Chip(
                      avatar: const Icon(Icons.schedule, size: 16),
                      label: Text(timeStr),
                      backgroundColor: Colors.grey.withOpacity(0.08),
                      side: BorderSide(color: Colors.grey.withOpacity(0.2)),
                      visualDensity: VisualDensity.compact,
                      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                    ),
                    Chip(
                      label: Text((status ?? '').toUpperCase()),
                      backgroundColor: statusColor.withOpacity(0.08),
                      side: BorderSide(color: statusColor.withOpacity(0.2)),
                      visualDensity: VisualDensity.compact,
                      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                    ),
                  ],
                ),
              ),
              trailing: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Text(
                    amountStr,
                    style: const TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.bold,
                      color: Colors.green,
                    ),
                  ),
                  if (cobradorName.isNotEmpty)
                    SizedBox(
                      width: 120,
                      child: Text(
                        cobradorName,
                        maxLines: 1,
                        textAlign: TextAlign.right,
                        overflow: TextOverflow.ellipsis,
                        style: const TextStyle(
                          fontSize: 11,
                          color: Colors.grey,
                        ),
                      ),
                    ),
                ],
              ),
            ),
          );
        },
      ),
    ],
  );
}

// Widget para mostrar distribuci√≥n por gravedad (Overdue Report)
Widget buildSeverityDistribution(Map severityMap, BuildContext context) {
  final light = severityMap['light'] ?? 0;
  final moderate = severityMap['moderate'] ?? 0;
  final severe = severityMap['severe'] ?? 0;
  final total = light + moderate + severe;

  if (total == 0) {
    return const Text('No hay datos de gravedad disponibles');
  }

  double lightPercent = (light / total) * 100;
  double moderatePercent = (moderate / total) * 100;
  double severePercent = (severe / total) * 100;

  return Column(
    children: [
      // Barras de progreso con porcentajes
      buildSeverityBar(
        context,
        'Ligera (1-7 d√≠as)',
        light,
        lightPercent,
        Colors.orange,
      ),
      const SizedBox(height: 12),
      buildSeverityBar(
        context,
        'Moderada (8-30 d√≠as)',
        moderate,
        moderatePercent,
        Colors.deepOrange,
      ),
      const SizedBox(height: 12),
      buildSeverityBar(
        context,
        'Severa (>30 d√≠as)',
        severe,
        severePercent,
        Colors.red,
      ),
    ],
  );
}

Widget buildSeverityBar(
  BuildContext context,
  String label,
  int count,
  double percent,
  Color color,
) {
  return Column(
    crossAxisAlignment: CrossAxisAlignment.start,
    children: [
      Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(label, style: const TextStyle(fontWeight: FontWeight.w500)),
          Row(
            children: [
              Text(
                '$count',
                style: TextStyle(fontWeight: FontWeight.bold, color: color),
              ),
              const SizedBox(width: 8),
              Text(
                '${percent.toStringAsFixed(1)}%',
                style: TextStyle(color: Colors.grey[600], fontSize: 12),
              ),
            ],
          ),
        ],
      ),
      const SizedBox(height: 6),
      ClipRRect(
        borderRadius: BorderRadius.circular(4),
        child: LinearProgressIndicator(
          value: percent / 100,
          backgroundColor: Colors.grey[200],
          valueColor: AlwaysStoppedAnimation<Color>(color),
          minHeight: 8,
        ),
      ),
    ],
  );
}

// Widget para mostrar Top 10 deudores (Overdue Report)
Widget buildTopDebtorsList(List topDebtors, BuildContext context) {
  if (topDebtors.isEmpty) {
    return const Text('No hay datos de deudores disponibles');
  }

  return ListView.separated(
    shrinkWrap: true,
    physics: const NeverScrollableScrollPhysics(),
    itemCount: topDebtors.length > 10 ? 10 : topDebtors.length,
    separatorBuilder: (_, __) => const Divider(height: 1),
    itemBuilder: (ctx, i) {
      final debtor = topDebtors[i] as Map;
      final clientName = debtor['client_name']?.toString() ?? 'Cliente';
      final creditId = debtor['credit_id']?.toString() ?? '';
      final daysOverdue = debtor['days_overdue']?.toString() ?? '0';
      final overdueAmount = debtor['overdue_amount'];
      final totalBalance = debtor['total_balance'];

      // Determinar color seg√∫n posici√≥n
      Color rankColor = Colors.grey;
      if (i == 0)
        rankColor = Colors.amber[700]!;
      else if (i == 1)
        rankColor = Colors.grey[400]!;
      else if (i == 2)
        rankColor = Colors.brown[300]!;

      return ListTile(
        dense: true,
        leading: CircleAvatar(
          backgroundColor: rankColor.withOpacity(0.15),
          foregroundColor: rankColor,
          radius: 18,
          child: Text(
            '${i + 1}',
            style: const TextStyle(fontWeight: FontWeight.bold),
          ),
        ),
        title: Text(
          clientName,
          style: const TextStyle(fontWeight: FontWeight.w600),
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
        subtitle: Text('Cr√©dito #$creditId ‚Ä¢ $daysOverdue d√≠as de mora'),
        trailing: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            Text(
              ReportFormatters.formatCurrency(overdueAmount),
              style: const TextStyle(
                fontWeight: FontWeight.bold,
                color: Colors.red,
                fontSize: 14,
              ),
            ),
            Text(
              'Balance: ${ReportFormatters.formatCurrency(totalBalance)}',
              style: TextStyle(fontSize: 11, color: Colors.grey[600]),
            ),
          ],
        ),
      );
    },
  );
}

// Widget para an√°lisis por cobrador (Overdue Report)
Widget buildCobradorAnalysis(Map cobradorMap, BuildContext context) {
  if (cobradorMap.isEmpty) {
    return const Text('No hay datos por cobrador disponibles');
  }

  final cobradores = cobradorMap.entries.toList();

  return ListView.separated(
    shrinkWrap: true,
    physics: const NeverScrollableScrollPhysics(),
    itemCount: cobradores.length,
    separatorBuilder: (_, __) => const Divider(height: 16),
    itemBuilder: (ctx, i) {
      final entry = cobradores[i];
      final cobradorName = entry.key;
      final data = entry.value as Map;
      final count = data['count'] ?? 0;
      final totalAmount = data['total_amount'] ?? 0;
      final avgDays = data['avg_days'] ?? 0.0;

      return Card(
        elevation: 0,
        color: Colors.blue.withOpacity(0.05),
        child: Padding(
          padding: const EdgeInsets.all(12.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  const Icon(Icons.person, size: 20, color: Colors.blue),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      cobradorName,
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 15,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceAround,
                children: [
                  buildCobradorStat('Cr√©ditos', '$count', Icons.receipt),
                  buildCobradorStat(
                    'Monto',
                    ReportFormatters.formatCurrency(totalAmount),
                    Icons.attach_money,
                  ),
                  buildCobradorStat(
                    'Promedio',
                    '${avgDays.toStringAsFixed(1)} d√≠as',
                    Icons.calendar_today,
                  ),
                ],
              ),
            ],
          ),
        ),
      );
    },
  );
}

Widget buildCobradorStat(String label, String value, IconData icon) {
  return Column(
    children: [
      Icon(icon, size: 18, color: Colors.blue[700]),
      const SizedBox(height: 4),
      Text(
        value,
        style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 13),
      ),
      Text(label, style: TextStyle(fontSize: 11, color: Colors.grey[600])),
    ],
  );
}

// Widget para an√°lisis por categor√≠a de cliente (Overdue Report)
Widget buildCategoryAnalysis(Map categoryMap, BuildContext context) {
  if (categoryMap.isEmpty) {
    return const Text('No hay datos por categor√≠a disponibles');
  }

  final categories = categoryMap.entries.toList();

  return Wrap(
    spacing: 12,
    runSpacing: 12,
    children: categories.map((entry) {
      final category = entry.key;
      final data = entry.value as Map;
      final count = data['count'] ?? 0;
      final totalAmount = data['total_amount'] ?? 0;

      Color categoryColor = Colors.purple;
      if (category == 'A') {
        categoryColor = Colors.green;
      } else if (category == 'B') {
        categoryColor = Colors.blue;
      } else if (category == 'C') {
        categoryColor = Colors.orange;
      }

      return SizedBox(
        width: 160,
        child: Card(
          elevation: 0,
          color: categoryColor.withOpacity(0.08),
          child: Padding(
            padding: const EdgeInsets.all(12.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    CircleAvatar(
                      backgroundColor: categoryColor.withOpacity(0.2),
                      foregroundColor: categoryColor,
                      radius: 16,
                      child: Text(
                        category,
                        style: const TextStyle(fontWeight: FontWeight.bold),
                      ),
                    ),
                    const SizedBox(width: 8),
                    Text(
                      'Categor√≠a $category',
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 13,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 12),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      'Cr√©ditos:',
                      style: TextStyle(fontSize: 12, color: Colors.grey[700]),
                    ),
                    Text(
                      '$count',
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 13,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 4),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      'Monto:',
                      style: TextStyle(fontSize: 12, color: Colors.grey[700]),
                    ),
                    Text(
                      ReportFormatters.formatCurrency(totalAmount),
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 12,
                        color: categoryColor,
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      );
    }).toList(),
  );
}

// Helper para botones de descarga reutilizable
Widget buildDownloadButtons(
  BuildContext context,
  WidgetRef ref,
  rp.ReportRequest req,
  Map payload,
) {
  return Row(
    children: [
      ElevatedButton.icon(
        onPressed: () async {
          try {
            final bytes = await ref
                .read(rp.reportsApiProvider)
                .generateReport(
                  req.type,
                  filters: req.filters,
                  format: 'excel',
                );
            if (bytes is List<int>) {
              final dir = await getApplicationDocumentsDirectory();
              final ts = DateTime.now().toIso8601String().replaceAll(':', '-');
              final fileName = 'reporte_${req.type}_$ts.xlsx';
              final file = File('${dir.path}/$fileName');
              await file.writeAsBytes(bytes);
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('Reporte guardado: $fileName'),
                  action: SnackBarAction(
                    label: 'Abrir',
                    onPressed: () {
                      OpenFilex.open(file.path);
                    },
                  ),
                ),
              );
              try {
                await OpenFilex.open(file.path);
              } catch (_) {}
            }
          } catch (e) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Error al descargar Excel: $e')),
            );
          }
        },
        icon: const Icon(Icons.grid_on),
        label: const Text('Excel'),
      ),
      const SizedBox(width: 8),
      ElevatedButton.icon(
        onPressed: () async {
          try {
            final bytes = await ref
                .read(rp.reportsApiProvider)
                .generateReport(req.type, filters: req.filters, format: 'pdf');
            if (bytes is List<int>) {
              final dir = await getApplicationDocumentsDirectory();
              final ts = DateTime.now().toIso8601String().replaceAll(':', '-');
              final fileName = 'reporte_${req.type}_$ts.pdf';
              final file = File('${dir.path}/$fileName');
              await file.writeAsBytes(bytes);
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('Reporte guardado: $fileName'),
                  action: SnackBarAction(
                    label: 'Abrir',
                    onPressed: () {
                      OpenFilex.open(file.path);
                    },
                  ),
                ),
              );
              try {
                await OpenFilex.open(file.path);
              } catch (_) {}
            }
          } catch (e) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Error al descargar PDF: $e')),
            );
          }
        },
        icon: const Icon(Icons.picture_as_pdf),
        label: const Text('PDF'),
      ),
      const SizedBox(width: 8),
      Expanded(
        child: Align(
          alignment: Alignment.centerRight,
          child:
              (payload['generated_by'] != null ||
                  payload['generated_at'] != null)
              ? Text(
                  'Generado' +
                      (payload['generated_by'] != null
                          ? ' por ${payload['generated_by']}'
                          : '') +
                      (payload['generated_at'] != null
                          ? ' ‚Ä¢ ${ReportFormatters.formatDate(payload['generated_at'])}'
                          : ''),
                  style: Theme.of(context).textTheme.bodySmall,
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                )
              : const SizedBox.shrink(),
        ),
      ),
    ],
  );
}

// === WIDGETS PARA PERFORMANCE REPORT ===

Widget buildTopPerformersList(List performers, BuildContext context) {
  return ListView.separated(
    shrinkWrap: true,
    physics: const NeverScrollableScrollPhysics(),
    itemCount: performers.length > 5 ? 5 : performers.length,
    separatorBuilder: (_, __) => const Divider(height: 1),
    itemBuilder: (ctx, i) {
      final performer = performers[i] as Map;
      final name = performer['name']?.toString() ?? 'Cobrador';
      final collectionRate = performer['collection_rate'] ?? 0;
      final portfolioQuality = performer['portfolio_quality'] ?? 0;

      Color rankColor = Colors.grey;
      if (i == 0)
        rankColor = Colors.amber[700]!;
      else if (i == 1)
        rankColor = Colors.grey[400]!;
      else if (i == 2)
        rankColor = Colors.brown[300]!;

      return ListTile(
        dense: true,
        leading: CircleAvatar(
          backgroundColor: rankColor.withOpacity(0.15),
          foregroundColor: rankColor,
          radius: 18,
          child: Text(
            '${i + 1}',
            style: const TextStyle(fontWeight: FontWeight.bold),
          ),
        ),
        title: Text(name, style: const TextStyle(fontWeight: FontWeight.w600)),
        subtitle: Text(
          'Cobranza: ${collectionRate.toStringAsFixed(1)}% ‚Ä¢ Calidad: ${portfolioQuality.toStringAsFixed(1)}%',
        ),
        trailing: const Icon(Icons.star, color: Colors.amber),
      );
    },
  );
}

Widget buildPerformanceList(List performance, BuildContext context) {
  return ListView.separated(
    shrinkWrap: true,
    physics: const NeverScrollableScrollPhysics(),
    itemCount: performance.length,
    separatorBuilder: (_, __) => const SizedBox(height: 12),
    itemBuilder: (ctx, i) {
      final p = performance[i] as Map;
      final cobradorName = p['cobrador_name']?.toString() ?? 'Cobrador';
      final managerName = p['manager_name']?.toString() ?? '';
      final metrics = p['metrics'] is Map ? p['metrics'] as Map : {};

      final creditsDelivered = metrics['credits_delivered'] ?? 0;
      final totalLent = metrics['total_amount_lent'] ?? 0;
      final totalCollected = metrics['total_amount_collected'] ?? 0;
      final collectionRate = metrics['collection_rate'] ?? 0;
      final portfolioQuality = metrics['portfolio_quality'] ?? 0;
      final efficiencyScore = metrics['efficiency_score'] ?? 0;
      final activeCredits = metrics['active_credits'] ?? 0;
      final overdueCredits = metrics['overdue_credits'] ?? 0;

      Color performanceColor = Colors.green;
      if (collectionRate < 60)
        performanceColor = Colors.red;
      else if (collectionRate < 75)
        performanceColor = Colors.orange;

      return Card(
        elevation: 2,
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  CircleAvatar(
                    backgroundColor: performanceColor.withOpacity(0.15),
                    foregroundColor: performanceColor,
                    child: Text('${i + 1}'),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          cobradorName,
                          style: const TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        if (managerName.isNotEmpty)
                          Text(
                            'Manager: $managerName',
                            style: TextStyle(
                              fontSize: 12,
                              color: Colors.grey[600],
                            ),
                          ),
                      ],
                    ),
                  ),
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.end,
                    children: [
                      Row(
                        children: [
                          Icon(Icons.star, size: 16, color: Colors.amber),
                          const SizedBox(width: 4),
                          Text(
                            efficiencyScore.toStringAsFixed(1),
                            style: const TextStyle(fontWeight: FontWeight.bold),
                          ),
                        ],
                      ),
                      Text(
                        'Eficiencia',
                        style: TextStyle(fontSize: 10, color: Colors.grey[600]),
                      ),
                    ],
                  ),
                ],
              ),
              const SizedBox(height: 12),
              const Divider(height: 1),
              const SizedBox(height: 12),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceAround,
                children: [
                  buildPerformanceStat(
                    'Entregados',
                    '$creditsDelivered',
                    Icons.local_shipping,
                    Colors.blue,
                  ),
                  buildPerformanceStat(
                    'Prestado',
                    ReportFormatters.formatCurrency(totalLent),
                    Icons.trending_up,
                    Colors.green,
                  ),
                  buildPerformanceStat(
                    'Cobrado',
                    ReportFormatters.formatCurrency(totalCollected),
                    Icons.payments,
                    Colors.teal,
                  ),
                ],
              ),
              const SizedBox(height: 12),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceAround,
                children: [
                  buildPerformanceStat(
                    'Tasa Cobranza',
                    '${collectionRate.toStringAsFixed(1)}%',
                    Icons.percent,
                    performanceColor,
                  ),
                  buildPerformanceStat(
                    'Calidad Cartera',
                    '${portfolioQuality.toStringAsFixed(1)}%',
                    Icons.star,
                    Colors.amber,
                  ),
                  buildPerformanceStat(
                    'Activos',
                    '$activeCredits',
                    Icons.trending_up,
                    Colors.indigo,
                  ),
                ],
              ),
              const SizedBox(height: 8),
              if (overdueCredits > 0)
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.red.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Row(
                    children: [
                      const Icon(Icons.warning, color: Colors.red, size: 16),
                      const SizedBox(width: 8),
                      Text(
                        '$overdueCredits cr√©ditos en mora',
                        style: const TextStyle(
                          color: Colors.red,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
                ),
            ],
          ),
        ),
      );
    },
  );
}

Widget buildPerformanceStat(
  String label,
  String value,
  IconData icon,
  Color color,
) {
  return Column(
    children: [
      Icon(icon, size: 20, color: color),
      const SizedBox(height: 4),
      Text(
        value,
        style: TextStyle(
          fontWeight: FontWeight.bold,
          fontSize: 14,
          color: color,
        ),
      ),
      Text(
        label,
        style: TextStyle(fontSize: 11, color: Colors.grey[600]),
        textAlign: TextAlign.center,
      ),
    ],
  );
}

// === WIDGETS PARA DAILY ACTIVITY REPORT ===

Widget buildDailyActivitiesList(List activities, BuildContext context) {
  return ListView.separated(
    shrinkWrap: true,
    physics: const NeverScrollableScrollPhysics(),
    itemCount: activities.length,
    separatorBuilder: (_, __) => const SizedBox(height: 12),
    itemBuilder: (ctx, i) {
      final activity = activities[i] as Map;
      final cobradorName = activity['cobrador_name']?.toString() ?? 'Cobrador';
      final cashBalance = activity['cash_balance'] is Map
          ? activity['cash_balance'] as Map
          : {};
      final creditsDelivered = activity['credits_delivered'] is Map
          ? activity['credits_delivered'] as Map
          : {};
      final paymentsCollected = activity['payments_collected'] is Map
          ? activity['payments_collected'] as Map
          : {};
      final expectedPayments = activity['expected_payments'] is Map
          ? activity['expected_payments'] as Map
          : {};

      final balanceStatus = cashBalance['status']?.toString() ?? 'not_opened';
      final efficiency = expectedPayments['efficiency'] ?? 0;

      Color statusColor = Colors.grey;
      String statusLabel = 'No abierta';
      if (balanceStatus == 'open') {
        statusColor = Colors.blue;
        statusLabel = 'Abierta';
      } else if (balanceStatus == 'closed') {
        statusColor = Colors.green;
        statusLabel = 'Cerrada';
      }

      return Card(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Icon(Icons.person, color: Colors.indigo),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      cobradorName,
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                  Chip(
                    label: Text(statusLabel),
                    backgroundColor: statusColor.withOpacity(0.1),
                    side: BorderSide(color: statusColor),
                    avatar: Icon(Icons.circle, size: 12, color: statusColor),
                  ),
                ],
              ),
              const SizedBox(height: 12),
              const Divider(height: 1),
              const SizedBox(height: 12),

              // Caja
              if (cashBalance.isNotEmpty) ...[
                Row(
                  children: [
                    Icon(
                      Icons.account_balance_wallet,
                      size: 20,
                      color: Colors.green,
                    ),
                    const SizedBox(width: 8),
                    const Text(
                      'Caja:',
                      style: TextStyle(fontWeight: FontWeight.w600),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                Wrap(
                  spacing: 12,
                  runSpacing: 8,
                  children: [
                    buildDailyStat(
                      'Inicial',
                      ReportFormatters.formatCurrency(cashBalance['initial_amount'] ?? 0),
                    ),
                    buildDailyStat(
                      'Recaudado',
                      ReportFormatters.formatCurrency(cashBalance['collected_amount'] ?? 0),
                    ),
                    buildDailyStat(
                      'Prestado',
                      ReportFormatters.formatCurrency(cashBalance['lent_amount'] ?? 0),
                    ),
                    buildDailyStat(
                      'Final',
                      ReportFormatters.formatCurrency(cashBalance['final_amount'] ?? 0),
                    ),
                  ],
                ),
                const SizedBox(height: 12),
              ],

              // Cr√©ditos entregados
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Row(
                    children: [
                      Icon(Icons.local_shipping, size: 20, color: Colors.blue),
                      const SizedBox(width: 8),
                      Text(
                        'Cr√©ditos entregados: ${creditsDelivered['count'] ?? 0}',
                      ),
                    ],
                  ),
                  Text(
                    ReportFormatters.formatCurrency(creditsDelivered['total_amount'] ?? 0),
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      color: Colors.green,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),

              // Pagos cobrados
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Row(
                    children: [
                      Icon(Icons.payment, size: 20, color: Colors.teal),
                      const SizedBox(width: 8),
                      Text(
                        'Pagos cobrados: ${paymentsCollected['count'] ?? 0}',
                      ),
                    ],
                  ),
                  Text(
                    ReportFormatters.formatCurrency(paymentsCollected['total_amount'] ?? 0),
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      color: Colors.green,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),

              // Eficiencia
              if (expectedPayments.isNotEmpty) ...[
                Row(
                  children: [
                    Icon(Icons.speed, size: 20, color: Colors.orange),
                    const SizedBox(width: 8),
                    Text('Eficiencia: '),
                    Text(
                      '${expectedPayments['collected'] ?? 0}/${expectedPayments['count'] ?? 0}',
                      style: const TextStyle(fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(width: 8),
                    Text(
                      '(${efficiency.toStringAsFixed(1)}%)',
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                        color: efficiency >= 80
                            ? Colors.green
                            : (efficiency >= 60 ? Colors.orange : Colors.red),
                      ),
                    ),
                  ],
                ),
              ],
            ],
          ),
        ),
      );
    },
  );
}

Widget buildDailyStat(String label, String value) {
  return Column(
    crossAxisAlignment: CrossAxisAlignment.start,
    children: [
      Text(label, style: TextStyle(fontSize: 11, color: Colors.grey[600])),
      Text(
        value,
        style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 13),
      ),
    ],
  );
}

// === WIDGETS PARA CASH FLOW FORECAST REPORT ===

Widget buildFrequencyDistribution(Map frequencies, BuildContext context) {
  final daily = frequencies['daily'] is Map ? frequencies['daily'] as Map : {};
  final weekly = frequencies['weekly'] is Map
      ? frequencies['weekly'] as Map
      : {};
  final biweekly = frequencies['biweekly'] is Map
      ? frequencies['biweekly'] as Map
      : {};
  final monthly = frequencies['monthly'] is Map
      ? frequencies['monthly'] as Map
      : {};

  return Column(
    children: [
      buildFrequencyRow(
        'Diario',
        daily['count'] ?? 0,
        daily['amount'] ?? 0,
        Colors.blue,
      ),
      const SizedBox(height: 8),
      buildFrequencyRow(
        'Semanal',
        weekly['count'] ?? 0,
        weekly['amount'] ?? 0,
        Colors.green,
      ),
      const SizedBox(height: 8),
      buildFrequencyRow(
        'Quincenal',
        biweekly['count'] ?? 0,
        biweekly['amount'] ?? 0,
        Colors.orange,
      ),
      const SizedBox(height: 8),
      buildFrequencyRow(
        'Mensual',
        monthly['count'] ?? 0,
        monthly['amount'] ?? 0,
        Colors.purple,
      ),
    ],
  );
}

Widget buildFrequencyRow(String label, int count, num amount, Color color) {
  return Row(
    mainAxisAlignment: MainAxisAlignment.spaceBetween,
    children: [
      Row(
        children: [
          Container(
            width: 12,
            height: 12,
            decoration: BoxDecoration(color: color, shape: BoxShape.circle),
          ),
          const SizedBox(width: 8),
          Text(label, style: const TextStyle(fontWeight: FontWeight.w500)),
        ],
      ),
      Row(
        children: [
          Text('$count pagos', style: TextStyle(color: Colors.grey[600])),
          const SizedBox(width: 12),
          Text(
            ReportFormatters.formatCurrency(amount),
            style: TextStyle(fontWeight: FontWeight.bold, color: color),
          ),
        ],
      ),
    ],
  );
}

Widget buildProjectionsList(List projections, BuildContext context) {
  return ListView.separated(
    shrinkWrap: true,
    physics: const NeverScrollableScrollPhysics(),
    itemCount: projections.length > 30 ? 30 : projections.length,
    separatorBuilder: (_, __) => const Divider(height: 1),
    itemBuilder: (ctx, i) {
      final proj = projections[i] as Map;
      final period = proj['period_label']?.toString() ?? '';
      final count = proj['count'] ?? 0;
      final totalAmount = proj['total_amount'] ?? 0;
      final overdueCount = proj['overdue_count'] ?? 0;
      final pendingCount = proj['pending_count'] ?? 0;

      return ListTile(
        dense: true,
        leading: CircleAvatar(
          backgroundColor: Colors.indigo.withOpacity(0.1),
          foregroundColor: Colors.indigo,
          child: Text('$count'),
        ),
        title: Text(
          period,
          style: const TextStyle(fontWeight: FontWeight.w600),
        ),
        subtitle: Row(
          children: [
            if (overdueCount > 0) ...[
              Icon(Icons.warning, size: 14, color: Colors.red),
              const SizedBox(width: 4),
              Text(
                '$overdueCount vencidos',
                style: const TextStyle(color: Colors.red, fontSize: 11),
              ),
              const SizedBox(width: 12),
            ],
            Icon(Icons.schedule, size: 14, color: Colors.orange),
            const SizedBox(width: 4),
            Text(
              '$pendingCount pendientes',
              style: TextStyle(color: Colors.grey[600], fontSize: 11),
            ),
          ],
        ),
        trailing: Text(
          ReportFormatters.formatCurrency(totalAmount),
          style: const TextStyle(
            fontWeight: FontWeight.bold,
            fontSize: 15,
            color: Colors.green,
          ),
        ),
      );
    },
  );
}

// === WIDGETS PARA PORTFOLIO REPORT ===

Widget buildTopClientsList(List clients, BuildContext context) {
  return ListView.separated(
    shrinkWrap: true,
    physics: const NeverScrollableScrollPhysics(),
    itemCount: clients.length > 10 ? 10 : clients.length,
    separatorBuilder: (_, __) => const Divider(height: 1),
    itemBuilder: (ctx, i) {
      final client = clients[i] as Map;
      final clientName = client['client_name']?.toString() ?? 'Cliente';
      final clientCategory = client['client_category']?.toString() ?? '';
      final creditId = client['credit_id']?.toString() ?? '';
      final balance = client['balance'] ?? 0;
      final totalAmount = client['total_amount'] ?? 0;
      final completionRate = client['completion_rate'] ?? 0;

      Color categoryColor = Colors.purple;
      if (clientCategory == 'A')
        categoryColor = Colors.green;
      else if (clientCategory == 'B')
        categoryColor = Colors.blue;
      else if (clientCategory == 'C')
        categoryColor = Colors.orange;

      return ListTile(
        dense: true,
        leading: CircleAvatar(
          backgroundColor: categoryColor.withOpacity(0.15),
          foregroundColor: categoryColor,
          child: Text(clientCategory.isNotEmpty ? clientCategory : '?'),
        ),
        title: Text(
          clientName,
          style: const TextStyle(fontWeight: FontWeight.w600),
        ),
        subtitle: Text(
          'Cr√©dito #$creditId ‚Ä¢ ${completionRate.toStringAsFixed(0)}% completado',
        ),
        trailing: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            Text(
              ReportFormatters.formatCurrency(balance),
              style: const TextStyle(
                fontWeight: FontWeight.bold,
                color: Colors.orange,
                fontSize: 14,
              ),
            ),
            Text(
              'de ${ReportFormatters.formatCurrency(totalAmount)}',
              style: TextStyle(fontSize: 11, color: Colors.grey[600]),
            ),
          ],
        ),
      );
    },
  );
}

Widget buildPortfolioByCobrador(Map portfolioMap, BuildContext context) {
  final cobradores = portfolioMap.entries.toList();

  return ListView.separated(
    shrinkWrap: true,
    physics: const NeverScrollableScrollPhysics(),
    itemCount: cobradores.length,
    separatorBuilder: (_, __) => const Divider(height: 16),
    itemBuilder: (ctx, i) {
      final entry = cobradores[i];
      final cobradorName = entry.key;
      final data = entry.value as Map;

      final totalCredits = data['total_credits'] ?? 0;
      final activeCredits = data['active_credits'] ?? 0;
      final totalBalance = data['total_balance'] ?? 0;
      final totalLent = data['total_lent'] ?? 0;
      final portfolioQuality = data['portfolio_quality'] ?? 0;
      final overdueCredits = data['overdue_credits'] ?? 0;

      Color qualityColor = Colors.green;
      if (portfolioQuality < 60)
        qualityColor = Colors.red;
      else if (portfolioQuality < 75)
        qualityColor = Colors.orange;

      return Card(
        elevation: 1,
        child: Padding(
          padding: const EdgeInsets.all(12.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Icon(Icons.person, color: Colors.indigo),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      cobradorName,
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 15,
                      ),
                    ),
                  ),
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: qualityColor.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(12),
                      border: Border.all(color: qualityColor),
                    ),
                    child: Text(
                      '${portfolioQuality.toStringAsFixed(0)}%',
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                        color: qualityColor,
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 12),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceAround,
                children: [
                  buildPortfolioStat(
                    'Total',
                    '$totalCredits',
                    Icons.assignment,
                  ),
                  buildPortfolioStat(
                    'Activos',
                    '$activeCredits',
                    Icons.trending_up,
                  ),
                  if (overdueCredits > 0)
                    buildPortfolioStat(
                      'Mora',
                      '$overdueCredits',
                      Icons.warning,
                    ),
                ],
              ),
              const SizedBox(height: 8),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text('Prestado:', style: TextStyle(color: Colors.grey[600])),
                  Text(
                    ReportFormatters.formatCurrency(totalLent),
                    style: const TextStyle(fontWeight: FontWeight.bold),
                  ),
                ],
              ),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text('Balance:', style: TextStyle(color: Colors.grey[600])),
                  Text(
                    ReportFormatters.formatCurrency(totalBalance),
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      color: Colors.orange,
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      );
    },
  );
}

Widget buildPortfolioStat(String label, String value, IconData icon) {
  return Column(
    children: [
      Icon(icon, size: 18, color: Colors.indigo),
      const SizedBox(height: 4),
      Text(
        value,
        style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 13),
      ),
      Text(label, style: TextStyle(fontSize: 11, color: Colors.grey[600])),
    ],
  );
}

Widget buildPortfolioByCategory(Map categoryMap, BuildContext context) {
  final categories = categoryMap.entries.toList();

  return Wrap(
    spacing: 12,
    runSpacing: 12,
    children: categories.map((entry) {
      final category = entry.key;
      final data = entry.value as Map;
      final totalCredits = data['total_credits'] ?? 0;
      final activeBalance = data['active_balance'] ?? 0;

      Color categoryColor = Colors.purple;
      if (category == 'A')
        categoryColor = Colors.green;
      else if (category == 'B')
        categoryColor = Colors.blue;
      else if (category == 'C')
        categoryColor = Colors.orange;

      return SizedBox(
        width: 160,
        child: Card(
          elevation: 0,
          color: categoryColor.withOpacity(0.08),
          child: Padding(
            padding: const EdgeInsets.all(12.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    CircleAvatar(
                      backgroundColor: categoryColor.withOpacity(0.2),
                      foregroundColor: categoryColor,
                      radius: 16,
                      child: Text(
                        category,
                        style: const TextStyle(fontWeight: FontWeight.bold),
                      ),
                    ),
                    const SizedBox(width: 8),
                    Text(
                      'Cat. $category',
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 13,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 12),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      'Cr√©ditos:',
                      style: TextStyle(fontSize: 12, color: Colors.grey[700]),
                    ),
                    Text(
                      '$totalCredits',
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 13,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 4),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      'Balance:',
                      style: TextStyle(fontSize: 12, color: Colors.grey[700]),
                    ),
                    Text(
                      ReportFormatters.formatCurrency(activeBalance),
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 12,
                        color: categoryColor,
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      );
    }).toList(),
  );
}